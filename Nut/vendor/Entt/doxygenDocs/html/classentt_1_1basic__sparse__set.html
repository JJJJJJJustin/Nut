<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>entt&#39;s architecture(Latest version 3.13.2): entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">entt&#39;s architecture(Latest version 3.13.2)<span id="projectnumber">&#160;beta 0.1</span>
   </div>
   <div id="projectbrief">This is all details in entt.hpp</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>entt</b></li><li class="navelem"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classentt_1_1basic__sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="entt_8hpp_source.html">entt.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for entt::basic_sparse_set&lt; Entity, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classentt_1_1basic__sparse__set.png" usemap="#entt::basic_5Fsparse_5Fset_3C_20Entity_2C_20Allocator_20_3E_map" alt=""/>
  <map id="entt::basic_5Fsparse_5Fset_3C_20Entity_2C_20Allocator_20_3E_map" name="entt::basic_5Fsparse_5Fset_3C_20Entity_2C_20Allocator_20_3E_map">
<area href="classentt_1_1basic__storage_3_01_entity_00_01_entity_00_01_allocator_01_4.html" title="Swap-only entity storage specialization." alt="entt::basic_storage&lt; Entity, Entity, Allocator &gt;" shape="rect" coords="0,56,272,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac1f56bb6b949b338ddad09977c631706" id="r_ac1f56bb6b949b338ddad09977c631706"><td class="memItemLeft" align="right" valign="top"><a id="ac1f56bb6b949b338ddad09977c631706" name="ac1f56bb6b949b338ddad09977c631706"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b> = <a class="el" href="structentt_1_1entt__traits.html">entt_traits</a>&lt;Entity&gt;</td></tr>
<tr class="memdesc:ac1f56bb6b949b338ddad09977c631706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits. <br /></td></tr>
<tr class="separator:ac1f56bb6b949b338ddad09977c631706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90adeddf9bab1f9c8b4b1fff95980f0" id="r_ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="memItemLeft" align="right" valign="top"><a id="ae90adeddf9bab1f9c8b4b1fff95980f0" name="ae90adeddf9bab1f9c8b4b1fff95980f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>entity_type</b> = typename <a class="el" href="classentt_1_1basic__entt__traits.html#a8d3ccdc302fc7dc567541fa12eca6b4e">traits_type::value_type</a></td></tr>
<tr class="memdesc:ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier. <br /></td></tr>
<tr class="separator:ae90adeddf9bab1f9c8b4b1fff95980f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e627591924feaaad4f04d13c4f4b2d" id="r_a14e627591924feaaad4f04d13c4f4b2d"><td class="memItemLeft" align="right" valign="top"><a id="a14e627591924feaaad4f04d13c4f4b2d" name="a14e627591924feaaad4f04d13c4f4b2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>version_type</b> = typename <a class="el" href="classentt_1_1basic__entt__traits.html#aa3fe33d19b228d07c5560b907f910c10">traits_type::version_type</a></td></tr>
<tr class="memdesc:a14e627591924feaaad4f04d13c4f4b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying version type. <br /></td></tr>
<tr class="separator:a14e627591924feaaad4f04d13c4f4b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec9530d8aa9ac94d421b27eb6998edb" id="r_a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memItemLeft" align="right" valign="top"><a id="a2ec9530d8aa9ac94d421b27eb6998edb" name="a2ec9530d8aa9ac94d421b27eb6998edb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6faaccfb0c465afb6173b0fb8a37069" id="r_af6faaccfb0c465afb6173b0fb8a37069"><td class="memItemLeft" align="right" valign="top"><a id="af6faaccfb0c465afb6173b0fb8a37069" name="af6faaccfb0c465afb6173b0fb8a37069"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="memdesc:af6faaccfb0c465afb6173b0fb8a37069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type. <br /></td></tr>
<tr class="separator:af6faaccfb0c465afb6173b0fb8a37069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b18963e68d4f003e19389fd342f90cc" id="r_a8b18963e68d4f003e19389fd342f90cc"><td class="memItemLeft" align="right" valign="top"><a id="a8b18963e68d4f003e19389fd342f90cc" name="a8b18963e68d4f003e19389fd342f90cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = typename packed_container_type::const_pointer</td></tr>
<tr class="memdesc:a8b18963e68d4f003e19389fd342f90cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to contained entities. <br /></td></tr>
<tr class="separator:a8b18963e68d4f003e19389fd342f90cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cea231ae7386a12487164d918f632b0" id="r_a6cea231ae7386a12487164d918f632b0"><td class="memItemLeft" align="right" valign="top"><a id="a6cea231ae7386a12487164d918f632b0" name="a6cea231ae7386a12487164d918f632b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td></tr>
<tr class="memdesc:a6cea231ae7386a12487164d918f632b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type. <br /></td></tr>
<tr class="separator:a6cea231ae7386a12487164d918f632b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688979d568f2450725d69aa89571f4f" id="r_a3688979d568f2450725d69aa89571f4f"><td class="memItemLeft" align="right" valign="top"><a id="a3688979d568f2450725d69aa89571f4f" name="a3688979d568f2450725d69aa89571f4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a></td></tr>
<tr class="memdesc:a3688979d568f2450725d69aa89571f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant random access iterator type. <br /></td></tr>
<tr class="separator:a3688979d568f2450725d69aa89571f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe62c143e816cf5e12078a607966c003" id="r_afe62c143e816cf5e12078a607966c003"><td class="memItemLeft" align="right" valign="top"><a id="afe62c143e816cf5e12078a607966c003" name="afe62c143e816cf5e12078a607966c003"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = std::reverse_iterator&lt;<a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&gt;</td></tr>
<tr class="memdesc:afe62c143e816cf5e12078a607966c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type. <br /></td></tr>
<tr class="separator:afe62c143e816cf5e12078a607966c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d66fda0fba1587a5f61e9c16f742f7" id="r_a27d66fda0fba1587a5f61e9c16f742f7"><td class="memItemLeft" align="right" valign="top"><a id="a27d66fda0fba1587a5f61e9c16f742f7" name="a27d66fda0fba1587a5f61e9c16f742f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = std::reverse_iterator&lt;<a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&gt;</td></tr>
<tr class="memdesc:a27d66fda0fba1587a5f61e9c16f742f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse iterator type. <br /></td></tr>
<tr class="separator:a27d66fda0fba1587a5f61e9c16f742f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc504894fc2c20ea25b7fc2864bd22e3" id="r_afc504894fc2c20ea25b7fc2864bd22e3"><td class="memItemLeft" align="right" valign="top"><a id="afc504894fc2c20ea25b7fc2864bd22e3" name="afc504894fc2c20ea25b7fc2864bd22e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basic_sparse_set</b> ()</td></tr>
<tr class="memdesc:afc504894fc2c20ea25b7fc2864bd22e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc504894fc2c20ea25b7fc2864bd22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b636566df9e6f3f36ff62d2bdde8d10" id="r_a1b636566df9e6f3f36ff62d2bdde8d10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b636566df9e6f3f36ff62d2bdde8d10">basic_sparse_set</a> (const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a1b636566df9e6f3f36ff62d2bdde8d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator.  <br /></td></tr>
<tr class="separator:a1b636566df9e6f3f36ff62d2bdde8d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e264ab5a7e2d97a204004d25b14238b" id="r_a8e264ab5a7e2d97a204004d25b14238b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e264ab5a7e2d97a204004d25b14238b">basic_sparse_set</a> (deletion_policy pol, const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator={})</td></tr>
<tr class="memdesc:a8e264ab5a7e2d97a204004d25b14238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given policy and allocator.  <br /></td></tr>
<tr class="separator:a8e264ab5a7e2d97a204004d25b14238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d35aae661fb35e485ac733969c84d9" id="r_af5d35aae661fb35e485ac733969c84d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d35aae661fb35e485ac733969c84d9">basic_sparse_set</a> (const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;elem, deletion_policy pol=deletion_policy::swap_and_pop, const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator={})</td></tr>
<tr class="memdesc:af5d35aae661fb35e485ac733969c84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given value type, policy and allocator.  <br /></td></tr>
<tr class="separator:af5d35aae661fb35e485ac733969c84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d881833f592ed21079e2a0fac8d2a" id="r_aaf4d881833f592ed21079e2a0fac8d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf4d881833f592ed21079e2a0fac8d2a">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aaf4d881833f592ed21079e2a0fac8d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:aaf4d881833f592ed21079e2a0fac8d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61f0d7c13b938d3524f0fe7f9c3a75" id="r_a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c61f0d7c13b938d3524f0fe7f9c3a75">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other, const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;allocator) noexcept</td></tr>
<tr class="memdesc:a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <br /></td></tr>
<tr class="separator:a8c61f0d7c13b938d3524f0fe7f9c3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56f048f614c38f14b19ba9cb27faa94" id="r_ac56f048f614c38f14b19ba9cb27faa94"><td class="memItemLeft" align="right" valign="top"><a id="ac56f048f614c38f14b19ba9cb27faa94" name="ac56f048f614c38f14b19ba9cb27faa94"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~basic_sparse_set</b> ()</td></tr>
<tr class="memdesc:ac56f048f614c38f14b19ba9cb27faa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ac56f048f614c38f14b19ba9cb27faa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f8aad7f89c040a3ef0e79ad9e814fb" id="r_a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53f8aad7f89c040a3ef0e79ad9e814fb">operator=</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a53f8aad7f89c040a3ef0e79ad9e814fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4866849ffb525cce7b4eee58b83a8" id="r_a0ba4866849ffb525cce7b4eee58b83a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba4866849ffb525cce7b4eee58b83a8">swap</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a0ba4866849ffb525cce7b4eee58b83a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents with those of a given sparse set.  <br /></td></tr>
<tr class="separator:a0ba4866849ffb525cce7b4eee58b83a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292b60dd8782739701906aec8f381ab" id="r_ab292b60dd8782739701906aec8f381ab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab292b60dd8782739701906aec8f381ab">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ab292b60dd8782739701906aec8f381ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated allocator.  <br /></td></tr>
<tr class="separator:ab292b60dd8782739701906aec8f381ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f80e4333c16c6c3786b041c8a7e8a2" id="r_a91f80e4333c16c6c3786b041c8a7e8a2"><td class="memItemLeft" align="right" valign="top">deletion_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f80e4333c16c6c3786b041c8a7e8a2">policy</a> () const noexcept</td></tr>
<tr class="memdesc:a91f80e4333c16c6c3786b041c8a7e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the deletion policy of a sparse set.  <br /></td></tr>
<tr class="separator:a91f80e4333c16c6c3786b041c8a7e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc26c3d5467a929c2b88d7ad915c1fa9" id="r_abc26c3d5467a929c2b88d7ad915c1fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc26c3d5467a929c2b88d7ad915c1fa9">free_list</a> () const noexcept</td></tr>
<tr class="memdesc:abc26c3d5467a929c2b88d7ad915c1fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head of the free list, if any.  <br /></td></tr>
<tr class="separator:abc26c3d5467a929c2b88d7ad915c1fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab753a85e80f82788764d74598a709eef" id="r_ab753a85e80f82788764d74598a709eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab753a85e80f82788764d74598a709eef">free_list</a> (const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> len) noexcept</td></tr>
<tr class="memdesc:ab753a85e80f82788764d74598a709eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the head of the free list, if possible.  <br /></td></tr>
<tr class="separator:ab753a85e80f82788764d74598a709eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d49df52ee3133a1347dc01131a4f1a" id="r_a58d49df52ee3133a1347dc01131a4f1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d49df52ee3133a1347dc01131a4f1a">reserve</a> (const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> cap)</td></tr>
<tr class="memdesc:a58d49df52ee3133a1347dc01131a4f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a sparse set.  <br /></td></tr>
<tr class="separator:a58d49df52ee3133a1347dc01131a4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b25baaceb061cd93da56f1ec24ee98" id="r_a17b25baaceb061cd93da56f1ec24ee98"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17b25baaceb061cd93da56f1ec24ee98">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a17b25baaceb061cd93da56f1ec24ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a sparse set has currently allocated space for.  <br /></td></tr>
<tr class="separator:a17b25baaceb061cd93da56f1ec24ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e10cc6ddc7ef9c733aabdec849c5b79" id="r_a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e10cc6ddc7ef9c733aabdec849c5b79">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <br /></td></tr>
<tr class="separator:a7e10cc6ddc7ef9c733aabdec849c5b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51c3904b0581866f8791a04435fc5f" id="r_a7e51c3904b0581866f8791a04435fc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e51c3904b0581866f8791a04435fc5f">extent</a> () const noexcept</td></tr>
<tr class="memdesc:a7e51c3904b0581866f8791a04435fc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <br /></td></tr>
<tr class="separator:a7e51c3904b0581866f8791a04435fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ad0662838fd351985a51ee3017fb6c" id="r_a69ad0662838fd351985a51ee3017fb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69ad0662838fd351985a51ee3017fb6c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a69ad0662838fd351985a51ee3017fb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <br /></td></tr>
<tr class="separator:a69ad0662838fd351985a51ee3017fb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8936d80c3656449118a7a7a08be6258" id="r_ad8936d80c3656449118a7a7a08be6258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8936d80c3656449118a7a7a08be6258">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ad8936d80c3656449118a7a7a08be6258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <br /></td></tr>
<tr class="separator:ad8936d80c3656449118a7a7a08be6258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ba15d734ea65f18e3c1fd5d748e5e" id="r_a736ba15d734ea65f18e3c1fd5d748e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a736ba15d734ea65f18e3c1fd5d748e5e">contiguous</a> () const noexcept</td></tr>
<tr class="memdesc:a736ba15d734ea65f18e3c1fd5d748e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is fully packed.  <br /></td></tr>
<tr class="separator:a736ba15d734ea65f18e3c1fd5d748e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c540ff32bca204b1adbd9e4f4a0240b" id="r_a4c540ff32bca204b1adbd9e4f4a0240b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8b18963e68d4f003e19389fd342f90cc">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c540ff32bca204b1adbd9e4f4a0240b">data</a> () const noexcept</td></tr>
<tr class="memdesc:a4c540ff32bca204b1adbd9e4f4a0240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <br /></td></tr>
<tr class="separator:a4c540ff32bca204b1adbd9e4f4a0240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b72852c0ae4f7f0dc5f27ba6001f42" id="r_a11b72852c0ae4f7f0dc5f27ba6001f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b72852c0ae4f7f0dc5f27ba6001f42">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a11b72852c0ae4f7f0dc5f27ba6001f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="separator:a11b72852c0ae4f7f0dc5f27ba6001f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1934fc85ed01c3528c45ab9a76712fa7" id="r_a1934fc85ed01c3528c45ab9a76712fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1934fc85ed01c3528c45ab9a76712fa7">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a1934fc85ed01c3528c45ab9a76712fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.     <br /></td></tr>
<tr class="separator:a1934fc85ed01c3528c45ab9a76712fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3187a76bdb963346a715e0ebd833bfd7" id="r_a3187a76bdb963346a715e0ebd833bfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7">end</a> () const noexcept</td></tr>
<tr class="memdesc:a3187a76bdb963346a715e0ebd833bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="separator:a3187a76bdb963346a715e0ebd833bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0cc6e746fd49b0c7a0b8e5d8504fef" id="r_a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f0cc6e746fd49b0c7a0b8e5d8504fef">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.     <br /></td></tr>
<tr class="separator:a9f0cc6e746fd49b0c7a0b8e5d8504fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba067d644dcb69d8d11f6d5dc48b9c9b" id="r_aba067d644dcb69d8d11f6d5dc48b9c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba067d644dcb69d8d11f6d5dc48b9c9b">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aba067d644dcb69d8d11f6d5dc48b9c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <br /></td></tr>
<tr class="separator:aba067d644dcb69d8d11f6d5dc48b9c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57b82c12d92837a14d8904e82eb49a9" id="r_ad57b82c12d92837a14d8904e82eb49a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57b82c12d92837a14d8904e82eb49a9">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ad57b82c12d92837a14d8904e82eb49a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.     <br /></td></tr>
<tr class="separator:ad57b82c12d92837a14d8904e82eb49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408ae201025279196f63ef32cf58da9a" id="r_a408ae201025279196f63ef32cf58da9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a408ae201025279196f63ef32cf58da9a">rend</a> () const noexcept</td></tr>
<tr class="memdesc:a408ae201025279196f63ef32cf58da9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <br /></td></tr>
<tr class="separator:a408ae201025279196f63ef32cf58da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f2f1c7bbf2861f4a3e7602a317b96" id="r_ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28f2f1c7bbf2861f4a3e7602a317b96">crend</a> () const noexcept</td></tr>
<tr class="memdesc:ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.     <br /></td></tr>
<tr class="separator:ab28f2f1c7bbf2861f4a3e7602a317b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffb3508f2658ac4c8fc7e9cedf7357" id="r_acbffb3508f2658ac4c8fc7e9cedf7357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbffb3508f2658ac4c8fc7e9cedf7357">begin</a> (int) const noexcept</td></tr>
<tr class="memdesc:acbffb3508f2658ac4c8fc7e9cedf7357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:acbffb3508f2658ac4c8fc7e9cedf7357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35065a7c11d26057cf6895c48d3d556b" id="r_a35065a7c11d26057cf6895c48d3d556b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35065a7c11d26057cf6895c48d3d556b">cbegin</a> (int) const noexcept</td></tr>
<tr class="memdesc:a35065a7c11d26057cf6895c48d3d556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.       Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:a35065a7c11d26057cf6895c48d3d556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcbd322a0c9e75b8312038aa738168a" id="r_a2bcbd322a0c9e75b8312038aa738168a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bcbd322a0c9e75b8312038aa738168a">end</a> (int) const noexcept</td></tr>
<tr class="memdesc:a2bcbd322a0c9e75b8312038aa738168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:a2bcbd322a0c9e75b8312038aa738168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f61ae117a50ee6f95370034eddbcac6" id="r_a3f61ae117a50ee6f95370034eddbcac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f61ae117a50ee6f95370034eddbcac6">cend</a> (int) const noexcept</td></tr>
<tr class="memdesc:a3f61ae117a50ee6f95370034eddbcac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.       Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:a3f61ae117a50ee6f95370034eddbcac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c5749cb58e7847c4add1d1a4a5389" id="r_ae66c5749cb58e7847c4add1d1a4a5389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66c5749cb58e7847c4add1d1a4a5389">rbegin</a> (int) const noexcept</td></tr>
<tr class="memdesc:ae66c5749cb58e7847c4add1d1a4a5389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:ae66c5749cb58e7847c4add1d1a4a5389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ce974020a335ab526bab0bdfd2f0fa" id="r_ab3ce974020a335ab526bab0bdfd2f0fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ce974020a335ab526bab0bdfd2f0fa">crbegin</a> (int) const noexcept</td></tr>
<tr class="memdesc:ab3ce974020a335ab526bab0bdfd2f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:ab3ce974020a335ab526bab0bdfd2f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd3ad7f579043af80022c0f4810ff6" id="r_acffd3ad7f579043af80022c0f4810ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acffd3ad7f579043af80022c0f4810ff6">rend</a> (int) const noexcept</td></tr>
<tr class="memdesc:acffd3ad7f579043af80022c0f4810ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:acffd3ad7f579043af80022c0f4810ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325b739a48422f5b77ca98c42970121f" id="r_a325b739a48422f5b77ca98c42970121f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a325b739a48422f5b77ca98c42970121f">crend</a> (int) const noexcept</td></tr>
<tr class="memdesc:a325b739a48422f5b77ca98c42970121f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy.  <br /></td></tr>
<tr class="separator:a325b739a48422f5b77ca98c42970121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9656b9f037aede492f66e87e57a6ca" id="r_a8b9656b9f037aede492f66e87e57a6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b9656b9f037aede492f66e87e57a6ca">find</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a8b9656b9f037aede492f66e87e57a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <br /></td></tr>
<tr class="separator:a8b9656b9f037aede492f66e87e57a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b47cbaea3fc30442fa3e6366766c86" id="r_a97b47cbaea3fc30442fa3e6366766c86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b47cbaea3fc30442fa3e6366766c86">contains</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a97b47cbaea3fc30442fa3e6366766c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <br /></td></tr>
<tr class="separator:a97b47cbaea3fc30442fa3e6366766c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf0ed9f37ededbd40f6a8c38c1940b" id="r_a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96cf0ed9f37ededbd40f6a8c38c1940b">current</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained version for an identifier.  <br /></td></tr>
<tr class="separator:a96cf0ed9f37ededbd40f6a8c38c1940b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a8fc74771c26b36fce8234f5e1d1fa" id="r_ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a8fc74771c26b36fce8234f5e1d1fa">index</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <br /></td></tr>
<tr class="separator:ad8a8fc74771c26b36fce8234f5e1d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1aab87bce23a757d40c5366ec2222e" id="r_ace1aab87bce23a757d40c5366ec2222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace1aab87bce23a757d40c5366ec2222e">at</a> (const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const noexcept</td></tr>
<tr class="memdesc:ace1aab87bce23a757d40c5366ec2222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, with bounds checking.  <br /></td></tr>
<tr class="separator:ace1aab87bce23a757d40c5366ec2222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba848e5d30f1f8fadce544d7bba7296a" id="r_aba848e5d30f1f8fadce544d7bba7296a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba848e5d30f1f8fadce544d7bba7296a">operator[]</a> (const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const noexcept</td></tr>
<tr class="memdesc:aba848e5d30f1f8fadce544d7bba7296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, without bounds checking.  <br /></td></tr>
<tr class="separator:aba848e5d30f1f8fadce544d7bba7296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3725f4fb86b9bb73f5f397884ff1680" id="r_ab3725f4fb86b9bb73f5f397884ff1680"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3725f4fb86b9bb73f5f397884ff1680">value</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) const noexcept</td></tr>
<tr class="memdesc:ab3725f4fb86b9bb73f5f397884ff1680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element assigned to an entity, if any.  <br /></td></tr>
<tr class="separator:ab3725f4fb86b9bb73f5f397884ff1680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f3827fb68d33cddbdb5519723ea6f" id="r_a319f3827fb68d33cddbdb5519723ea6f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319f3827fb68d33cddbdb5519723ea6f">value</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt) noexcept</td></tr>
<tr class="memdesc:a319f3827fb68d33cddbdb5519723ea6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element assigned to an entity, if any.     <br /></td></tr>
<tr class="separator:a319f3827fb68d33cddbdb5519723ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf01b2a8d20329ec1c1d5d3b5708969" id="r_a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cf01b2a8d20329ec1c1d5d3b5708969">push</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt, const void *elem=nullptr)</td></tr>
<tr class="memdesc:a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <br /></td></tr>
<tr class="separator:a8cf01b2a8d20329ec1c1d5d3b5708969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43205b128298f90d1255cf4ce768297c" id="r_a43205b128298f90d1255cf4ce768297c"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a43205b128298f90d1255cf4ce768297c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43205b128298f90d1255cf4ce768297c">push</a> (It first, It last)</td></tr>
<tr class="memdesc:a43205b128298f90d1255cf4ce768297c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one or more entities to a sparse set.  <br /></td></tr>
<tr class="separator:a43205b128298f90d1255cf4ce768297c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777ecee811e5fa5567bc462dba476771" id="r_a777ecee811e5fa5567bc462dba476771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a14e627591924feaaad4f04d13c4f4b2d">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a777ecee811e5fa5567bc462dba476771">bump</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a777ecee811e5fa5567bc462dba476771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bump the version number of an entity.  <br /></td></tr>
<tr class="separator:a777ecee811e5fa5567bc462dba476771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a41589e81003ca86b8a6104842680cb" id="r_a0a41589e81003ca86b8a6104842680cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a41589e81003ca86b8a6104842680cb">erase</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:a0a41589e81003ca86b8a6104842680cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:a0a41589e81003ca86b8a6104842680cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3bad1bb267d515e61fd717f4dbb011" id="r_a1f3bad1bb267d515e61fd717f4dbb011"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1f3bad1bb267d515e61fd717f4dbb011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f3bad1bb267d515e61fd717f4dbb011">erase</a> (It first, It last)</td></tr>
<tr class="memdesc:a1f3bad1bb267d515e61fd717f4dbb011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a set.  <br /></td></tr>
<tr class="separator:a1f3bad1bb267d515e61fd717f4dbb011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e5833d5edb2450303bd1c029213b8" id="r_af02e5833d5edb2450303bd1c029213b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af02e5833d5edb2450303bd1c029213b8">remove</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> entt)</td></tr>
<tr class="memdesc:af02e5833d5edb2450303bd1c029213b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set if it exists.  <br /></td></tr>
<tr class="separator:af02e5833d5edb2450303bd1c029213b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4ee6c81e845f332c35c89acb8f436" id="r_ab2b4ee6c81e845f332c35c89acb8f436"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ab2b4ee6c81e845f332c35c89acb8f436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2b4ee6c81e845f332c35c89acb8f436">remove</a> (It first, It last)</td></tr>
<tr class="memdesc:ab2b4ee6c81e845f332c35c89acb8f436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes entities from a sparse set if they exist.  <br /></td></tr>
<tr class="separator:ab2b4ee6c81e845f332c35c89acb8f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4979ce48546cfcc705c4d23654faef2" id="r_af4979ce48546cfcc705c4d23654faef2"><td class="memItemLeft" align="right" valign="top"><a id="af4979ce48546cfcc705c4d23654faef2" name="af4979ce48546cfcc705c4d23654faef2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compact</b> ()</td></tr>
<tr class="memdesc:af4979ce48546cfcc705c4d23654faef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all tombstones from a sparse set. <br /></td></tr>
<tr class="separator:af4979ce48546cfcc705c4d23654faef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82af720eca37261f3230c654d7fe1f" id="r_a2b82af720eca37261f3230c654d7fe1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b82af720eca37261f3230c654d7fe1f">swap_elements</a> (const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> lhs, const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> rhs)</td></tr>
<tr class="memdesc:a2b82af720eca37261f3230c654d7fe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in a sparse set.  <br /></td></tr>
<tr class="separator:a2b82af720eca37261f3230c654d7fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c1c0aa0fa525e12cee0791cd945915" id="r_a43c1c0aa0fa525e12cee0791cd945915"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a43c1c0aa0fa525e12cee0791cd945915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43c1c0aa0fa525e12cee0791cd945915">sort_n</a> (const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> length, Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a43c1c0aa0fa525e12cee0791cd945915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the first count elements according to the given comparison function.  <br /></td></tr>
<tr class="separator:a43c1c0aa0fa525e12cee0791cd945915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ceed81905adc0d65291eb9f4072f08" id="r_ae7ceed81905adc0d65291eb9f4072f08"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:ae7ceed81905adc0d65291eb9f4072f08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7ceed81905adc0d65291eb9f4072f08">sort</a> (Compare compare, Sort algo=Sort{}, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7ceed81905adc0d65291eb9f4072f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements according to the given comparison function.  <br /></td></tr>
<tr class="separator:ae7ceed81905adc0d65291eb9f4072f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19597c6dd5a2db98b0e343fcf5572a5" id="r_ae19597c6dd5a2db98b0e343fcf5572a5"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ae19597c6dd5a2db98b0e343fcf5572a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae19597c6dd5a2db98b0e343fcf5572a5">sort_as</a> (It first, It last)</td></tr>
<tr class="memdesc:ae19597c6dd5a2db98b0e343fcf5572a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in a range.  <br /></td></tr>
<tr class="separator:ae19597c6dd5a2db98b0e343fcf5572a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785d2733c7087fba3c03612403094420" id="r_a785d2733c7087fba3c03612403094420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785d2733c7087fba3c03612403094420">sort_as</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:a785d2733c7087fba3c03612403094420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in a range.     <br /></td></tr>
<tr class="separator:a785d2733c7087fba3c03612403094420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560773b887906122d50a413aea1faad" id="r_a6560773b887906122d50a413aea1faad"><td class="memItemLeft" align="right" valign="top"><a id="a6560773b887906122d50a413aea1faad" name="a6560773b887906122d50a413aea1faad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a6560773b887906122d50a413aea1faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a sparse set. <br /></td></tr>
<tr class="separator:a6560773b887906122d50a413aea1faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37830b84f2801670927b8ae881d72b7" id="r_ae37830b84f2801670927b8ae881d72b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37830b84f2801670927b8ae881d72b7">type</a> () const noexcept</td></tr>
<tr class="memdesc:ae37830b84f2801670927b8ae881d72b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned value type, if any.  <br /></td></tr>
<tr class="separator:ae37830b84f2801670927b8ae881d72b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db791610e0925291f9213681b0d4a9f" id="r_a9db791610e0925291f9213681b0d4a9f"><td class="memItemLeft" align="right" valign="top"><a id="a9db791610e0925291f9213681b0d4a9f" name="a9db791610e0925291f9213681b0d4a9f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (<a class="el" href="classentt_1_1basic__any.html">any</a>) noexcept</td></tr>
<tr class="memdesc:a9db791610e0925291f9213681b0d4a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards variables to derived classes, if any. <br /></td></tr>
<tr class="separator:a9db791610e0925291f9213681b0d4a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac56bb654b47a648d64a754d85c70b40a" id="r_ac56bb654b47a648d64a754d85c70b40a"><td class="memItemLeft" align="right" valign="top"><a id="ac56bb654b47a648d64a754d85c70b40a" name="ac56bb654b47a648d64a754d85c70b40a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>basic_iterator</b> = internal::sparse_set_iterator&lt;packed_container_type&gt;</td></tr>
<tr class="memdesc:ac56bb654b47a648d64a754d85c70b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type. <br /></td></tr>
<tr class="separator:ac56bb654b47a648d64a754d85c70b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abde0af92d2d8eade7b5acf5ab02f8038" id="r_abde0af92d2d8eade7b5acf5ab02f8038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde0af92d2d8eade7b5acf5ab02f8038">swap_only</a> (const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:abde0af92d2d8eade7b5acf5ab02f8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:abde0af92d2d8eade7b5acf5ab02f8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b95c0acd8af718e712362d1177dbc1e" id="r_a2b95c0acd8af718e712362d1177dbc1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b95c0acd8af718e712362d1177dbc1e">swap_and_pop</a> (const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:a2b95c0acd8af718e712362d1177dbc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:a2b95c0acd8af718e712362d1177dbc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45b7ab945ade01c286a35cba5376d7f" id="r_aa45b7ab945ade01c286a35cba5376d7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45b7ab945ade01c286a35cba5376d7f">in_place_pop</a> (const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> it)</td></tr>
<tr class="memdesc:aa45b7ab945ade01c286a35cba5376d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <br /></td></tr>
<tr class="separator:aa45b7ab945ade01c286a35cba5376d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f66cbcaa360286d296dcb7a33c7e1ce" id="r_a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f66cbcaa360286d296dcb7a33c7e1ce">pop</a> (<a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> first, <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> last)</td></tr>
<tr class="memdesc:a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a sparse set.  <br /></td></tr>
<tr class="separator:a8f66cbcaa360286d296dcb7a33c7e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8e00e8bfa75311482f2fa071e244e6" id="r_a1e8e00e8bfa75311482f2fa071e244e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8e00e8bfa75311482f2fa071e244e6">pop_all</a> ()</td></tr>
<tr class="memdesc:a1e8e00e8bfa75311482f2fa071e244e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all entities of a sparse set.  <br /></td></tr>
<tr class="separator:a1e8e00e8bfa75311482f2fa071e244e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c62d9615acde55f57fcca92e44c747c" id="r_a1c62d9615acde55f57fcca92e44c747c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c62d9615acde55f57fcca92e44c747c">try_emplace</a> (const Entity entt, const bool force_back, const void *=nullptr)</td></tr>
<tr class="memdesc:a1c62d9615acde55f57fcca92e44c747c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <br /></td></tr>
<tr class="separator:a1c62d9615acde55f57fcca92e44c747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Entity, typename Allocator&gt;<br />
class entt::basic_sparse_set&lt; Entity, Allocator &gt;</div><p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br  />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br  />
 This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>Internal data structures arrange elements to maximize performance. There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b636566df9e6f3f36ff62d2bdde8d10" name="a1b636566df9e6f3f36ff62d2bdde8d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b636566df9e6f3f36ff62d2bdde8d10">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e264ab5a7e2d97a204004d25b14238b" name="a8e264ab5a7e2d97a204004d25b14238b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e264ab5a7e2d97a204004d25b14238b">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype">deletion_policy</td>          <td class="paramname"><span class="paramname"><em>pol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given policy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Type of deletion policy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d35aae661fb35e485ac733969c84d9" name="af5d35aae661fb35e485ac733969c84d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d35aae661fb35e485ac733969c84d9">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>elem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">deletion_policy</td>          <td class="paramname"><span class="paramname"><em>pol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">deletion_policy::swap_and_pop</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given value type, policy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Returned value type, if any. </td></tr>
    <tr><td class="paramname">pol</td><td>Type of deletion policy. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf4d881833f592ed21079e2a0fac8d2a" name="aaf4d881833f592ed21079e2a0fac8d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4d881833f592ed21079e2a0fac8d2a">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c61f0d7c13b938d3524f0fe7f9c3a75" name="a8c61f0d7c13b938d3524f0fe7f9c3a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c61f0d7c13b938d3524f0fe7f9c3a75">&#9670;&#160;</a></span>basic_sparse_set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::basic_sparse_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace1aab87bce23a757d40c5366ec2222e" name="ace1aab87bce23a757d40c5366ec2222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1aab87bce23a757d40c5366ec2222e">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location if any, a null entity otherwise. </dd></dl>

</div>
</div>
<a id="a11b72852c0ae4f7f0dc5f27ba6001f42" name="a11b72852c0ae4f7f0dc5f27ba6001f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b72852c0ae4f7f0dc5f27ba6001f42">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set. </dd></dl>

</div>
</div>
<a id="acbffb3508f2658ac4c8fc7e9cedf7357" name="acbffb3508f2658ac4c8fc7e9cedf7357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbffb3508f2658ac4c8fc7e9cedf7357">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.    Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a777ecee811e5fa5567bc462dba476771" name="a777ecee811e5fa5567bc462dba476771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777ecee811e5fa5567bc462dba476771">&#9670;&#160;</a></span>bump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14e627591924feaaad4f04d13c4f4b2d">version_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::bump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bump the version number of an entity. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to bump the version of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The version of the given identifier. </dd></dl>

</div>
</div>
<a id="a17b25baaceb061cd93da56f1ec24ee98" name="a17b25baaceb061cd93da56f1ec24ee98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b25baaceb061cd93da56f1ec24ee98">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a sparse set has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the sparse set. </dd></dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a45d9ea8409804572c0ec705c2bc8c293">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#a45d9ea8409804572c0ec705c2bc8c293">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="a1934fc85ed01c3528c45ab9a76712fa7" name="a1934fc85ed01c3528c45ab9a76712fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1934fc85ed01c3528c45ab9a76712fa7">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.    </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set.    </dd></dl>

</div>
</div>
<a id="a35065a7c11d26057cf6895c48d3d556b" name="a35065a7c11d26057cf6895c48d3d556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35065a7c11d26057cf6895c48d3d556b">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.       Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the sparse set.       Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a9f0cc6e746fd49b0c7a0b8e5d8504fef" name="a9f0cc6e746fd49b0c7a0b8e5d8504fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0cc6e746fd49b0c7a0b8e5d8504fef">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.    </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set.    </dd></dl>

</div>
</div>
<a id="a3f61ae117a50ee6f95370034eddbcac6" name="a3f61ae117a50ee6f95370034eddbcac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f61ae117a50ee6f95370034eddbcac6">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.       Useful only in case of swap-only policy. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set.       Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a97b47cbaea3fc30442fa3e6366766c86" name="a97b47cbaea3fc30442fa3e6366766c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b47cbaea3fc30442fa3e6366766c86">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

</div>
</div>
<a id="a736ba15d734ea65f18e3c1fd5d748e5e" name="a736ba15d734ea65f18e3c1fd5d748e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736ba15d734ea65f18e3c1fd5d748e5e">&#9670;&#160;</a></span>contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::contiguous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is fully packed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is fully packed, false otherwise. </dd></dl>

</div>
</div>
<a id="ad57b82c12d92837a14d8904e82eb49a9" name="ad57b82c12d92837a14d8904e82eb49a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57b82c12d92837a14d8904e82eb49a9">&#9670;&#160;</a></span>crbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.    </dd></dl>

</div>
</div>
<a id="ab3ce974020a335ab526bab0bdfd2f0fa" name="ab3ce974020a335ab526bab0bdfd2f0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ce974020a335ab526bab0bdfd2f0fa">&#9670;&#160;</a></span>crbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crbegin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="ab28f2f1c7bbf2861f4a3e7602a317b96" name="ab28f2f1c7bbf2861f4a3e7602a317b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28f2f1c7bbf2861f4a3e7602a317b96">&#9670;&#160;</a></span>crend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end.    </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed sparse set.    </dd></dl>

</div>
</div>
<a id="a325b739a48422f5b77ca98c42970121f" name="a325b739a48422f5b77ca98c42970121f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325b739a48422f5b77ca98c42970121f">&#9670;&#160;</a></span>crend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a27d66fda0fba1587a5f61e9c16f742f7">const_reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::crend </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a96cf0ed9f37ededbd40f6a8c38c1940b" name="a96cf0ed9f37ededbd40f6a8c38c1940b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf0ed9f37ededbd40f6a8c38c1940b">&#9670;&#160;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a14e627591924feaaad4f04d13c4f4b2d">version_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::current </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained version for an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The version for the given identifier if present, the tombstone version otherwise. </dd></dl>

</div>
</div>
<a id="a4c540ff32bca204b1adbd9e4f4a0240b" name="a4c540ff32bca204b1adbd9e4f4a0240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c540ff32bca204b1adbd9e4f4a0240b">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8b18963e68d4f003e19389fd342f90cc">pointer</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

</div>
</div>
<a id="ad8936d80c3656449118a7a7a08be6258" name="ad8936d80c3656449118a7a7a08be6258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8936d80c3656449118a7a7a08be6258">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a3187a76bdb963346a715e0ebd833bfd7" name="a3187a76bdb963346a715e0ebd833bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3187a76bdb963346a715e0ebd833bfd7">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set. </dd></dl>

</div>
</div>
<a id="a2bcbd322a0c9e75b8312038aa738168a" name="a2bcbd322a0c9e75b8312038aa738168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcbd322a0c9e75b8312038aa738168a">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.    Useful only in case of swap-only policy. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of a sparse set.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a0a41589e81003ca86b8a6104842680cb" name="a0a41589e81003ca86b8a6104842680cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a41589e81003ca86b8a6104842680cb">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to erase an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f3bad1bb267d515e61fd717f4dbb011" name="a1f3bad1bb267d515e61fd717f4dbb011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3bad1bb267d515e61fd717f4dbb011">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0a41589e81003ca86b8a6104842680cb" title="Erases an entity from a sparse set.">erase</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e51c3904b0581866f8791a04435fc5f" name="a7e51c3904b0581866f8791a04435fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51c3904b0581866f8791a04435fc5f">&#9670;&#160;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::extent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of a sparse set. </p>
<p>The extent of a sparse set is also the size of the internal sparse array. There is no guarantee that the internal packed array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Extent of the sparse set. </dd></dl>

</div>
</div>
<a id="a8b9656b9f037aede492f66e87e57a6ca" name="a8b9656b9f037aede492f66e87e57a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9656b9f037aede492f66e87e57a6ca">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3688979d568f2450725d69aa89571f4f">const_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the given entity if it's found, past the end iterator otherwise. </dd></dl>

</div>
</div>
<a id="abc26c3d5467a929c2b88d7ad915c1fa9" name="abc26c3d5467a929c2b88d7ad915c1fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc26c3d5467a929c2b88d7ad915c1fa9">&#9670;&#160;</a></span>free_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::free_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the head of the free list, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>The head of the free list. </dd></dl>

</div>
</div>
<a id="ab753a85e80f82788764d74598a709eef" name="ab753a85e80f82788764d74598a709eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab753a85e80f82788764d74598a709eef">&#9670;&#160;</a></span>free_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::free_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the head of the free list, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The value to use as the new head of the free list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab292b60dd8782739701906aec8f381ab" name="ab292b60dd8782739701906aec8f381ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab292b60dd8782739701906aec8f381ab">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af6faaccfb0c465afb6173b0fb8a37069">allocator_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="aa45b7ab945ade01c286a35cba5376d7f" name="aa45b7ab945ade01c286a35cba5376d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45b7ab945ade01c286a35cba5376d7f">&#9670;&#160;</a></span>in_place_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::in_place_pop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator to the element to pop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8a8fc74771c26b36fce8234f5e1d1fa" name="ad8a8fc74771c26b36fce8234f5e1d1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a8fc74771c26b36fce8234f5e1d1fa">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

</div>
</div>
<a id="a53f8aad7f89c040a3ef0e79ad9e814fb" name="a53f8aad7f89c040a3ef0e79ad9e814fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f8aad7f89c040a3ef0e79ad9e814fb">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

</div>
</div>
<a id="aba848e5d30f1f8fadce544d7bba7296a" name="aba848e5d30f1f8fadce544d7bba7296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba848e5d30f1f8fadce544d7bba7296a">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location. </dd></dl>

</div>
</div>
<a id="a91f80e4333c16c6c3786b041c8a7e8a2" name="a91f80e4333c16c6c3786b041c8a7e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f80e4333c16c6c3786b041c8a7e8a2">&#9670;&#160;</a></span>policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">deletion_policy <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the deletion policy of a sparse set. </p>
<dl class="section return"><dt>Returns</dt><dd>The deletion policy of the sparse set. </dd></dl>

</div>
</div>
<a id="a8f66cbcaa360286d296dcb7a33c7e1ce" name="a8f66cbcaa360286d296dcb7a33c7e1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f66cbcaa360286d296dcb7a33c7e1ce">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ab2d0f02c4c0a88d6fe42b95e9c2b8226">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#ab2d0f02c4c0a88d6fe42b95e9c2b8226">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="a1e8e00e8bfa75311482f2fa071e244e6" name="a1e8e00e8bfa75311482f2fa071e244e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8e00e8bfa75311482f2fa071e244e6">&#9670;&#160;</a></span>pop_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::pop_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all entities of a sparse set. </p>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a343212f5eacd1e124fb85be1a6841b60">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#a343212f5eacd1e124fb85be1a6841b60">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="a8cf01b2a8d20329ec1c1d5d3b5708969" name="a8cf01b2a8d20329ec1c1d5d3b5708969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf01b2a8d20329ec1c1d5d3b5708969">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>elem</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">elem</td><td>Optional opaque element to forward to mixins, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element in case of success, the <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code> iterator otherwise. </dd></dl>

</div>
</div>
<a id="a43205b128298f90d1255cf4ce768297c" name="a43205b128298f90d1255cf4ce768297c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43205b128298f90d1255cf4ce768297c">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6cea231ae7386a12487164d918f632b0">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::push </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns one or more entities to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element inserted in case of success, the <code><a class="el" href="#a3187a76bdb963346a715e0ebd833bfd7" title="Returns an iterator to the end.">end()</a></code> iterator otherwise. </dd></dl>

</div>
</div>
<a id="aba067d644dcb69d8d11f6d5dc48b9c9b" name="aba067d644dcb69d8d11f6d5dc48b9c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba067d644dcb69d8d11f6d5dc48b9c9b">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array. </dd></dl>

</div>
</div>
<a id="ae66c5749cb58e7847c4add1d1a4a5389" name="ae66c5749cb58e7847c4add1d1a4a5389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66c5749cb58e7847c4add1d1a4a5389">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="af02e5833d5edb2450303bd1c029213b8" name="af02e5833d5edb2450303bd1c029213b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e5833d5edb2450303bd1c029213b8">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity is actually removed, false otherwise. </dd></dl>

</div>
</div>
<a id="ab2b4ee6c81e845f332c35c89acb8f436" name="ab2b4ee6c81e845f332c35c89acb8f436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b4ee6c81e845f332c35c89acb8f436">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes entities from a sparse set if they exist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entities actually removed. </dd></dl>

</div>
</div>
<a id="a408ae201025279196f63ef32cf58da9a" name="a408ae201025279196f63ef32cf58da9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ae201025279196f63ef32cf58da9a">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed sparse set. </dd></dl>

</div>
</div>
<a id="acffd3ad7f579043af80022c0f4810ff6" name="acffd3ad7f579043af80022c0f4810ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffd3ad7f579043af80022c0f4810ff6">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning.    Useful only in case of swap-only policy. </p>
<p>If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="#a408ae201025279196f63ef32cf58da9a" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array.    Useful only in case of swap-only policy. </dd></dl>

</div>
</div>
<a id="a58d49df52ee3133a1347dc01131a4f1a" name="a58d49df52ee3133a1347dc01131a4f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d49df52ee3133a1347dc01131a4f1a">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a sparse set. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ad51850043e05582865e5c93fa06421be">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#ad51850043e05582865e5c93fa06421be">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="a7e10cc6ddc7ef9c733aabdec849c5b79" name="a7e10cc6ddc7ef9c733aabdec849c5b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e10cc6ddc7ef9c733aabdec849c5b79">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#ad569287dadaa314c700f0e904ef71409">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#ad569287dadaa314c700f0e904ef71409">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="a69ad0662838fd351985a51ee3017fb6c" name="a69ad0662838fd351985a51ee3017fb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ad0662838fd351985a51ee3017fb6c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

</div>
</div>
<a id="ae7ceed81905adc0d65291eb9f4072f08" name="ae7ceed81905adc0d65291eb9f4072f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ceed81905adc0d65291eb9f4072f08">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort</td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Sort{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all elements according to the given comparison function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a43c1c0aa0fa525e12cee0791cd945915" title="Sort the first count elements according to the given comparison function.">sort_n</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a785d2733c7087fba3c03612403094420" name="a785d2733c7087fba3c03612403094420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785d2733c7087fba3c03612403094420">&#9670;&#160;</a></span>sort_as() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in a range.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae19597c6dd5a2db98b0e343fcf5572a5" name="ae19597c6dd5a2db98b0e343fcf5572a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19597c6dd5a2db98b0e343fcf5572a5">&#9670;&#160;</a></span>sort_as() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_as </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in a range. </p>
<p>Entities that are part of both the sparse set and the range are ordered internally according to the order they have in the range.<br  />
 All other entities goes to the end of the sparse set and there are no guarantees on their order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43c1c0aa0fa525e12cee0791cd945915" name="a43c1c0aa0fa525e12cee0791cd945915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c1c0aa0fa525e12cee0791cd945915">&#9670;&#160;</a></span>sort_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort</td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Sort{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the first count elements according to the given comparison function. </p>
<p>The comparison function object must return <code>true</code> if the first element is <em>less</em> than the second one, <code>false</code> otherwise. The signature of the comparison function should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><p>Moreover, the comparison function object shall induce a <em>strict weak ordering</em> on the values.</p>
<p>The sort function object must offer a member function template <code>operator()</code> that accepts three arguments:</p>
<ul>
<li>An iterator to the first element of the range to sort.</li>
<li>An iterator past the last element of the range to sort.</li>
<li>A comparison function to use to compare the elements.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba4866849ffb525cce7b4eee58b83a8" name="a0ba4866849ffb525cce7b4eee58b83a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba4866849ffb525cce7b4eee58b83a8">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents with those of a given sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Sparse set to exchange the content with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b95c0acd8af718e712362d1177dbc1e" name="a2b95c0acd8af718e712362d1177dbc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b95c0acd8af718e712362d1177dbc1e">&#9670;&#160;</a></span>swap_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_and_pop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator to the element to pop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b82af720eca37261f3230c654d7fe1f" name="a2b82af720eca37261f3230c654d7fe1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82af720eca37261f3230c654d7fe1f">&#9670;&#160;</a></span>swap_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in a sparse set. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abde0af92d2d8eade7b5acf5ab02f8038" name="abde0af92d2d8eade7b5acf5ab02f8038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde0af92d2d8eade7b5acf5ab02f8038">&#9670;&#160;</a></span>swap_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_only </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator to the element to pop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c62d9615acde55f57fcca92e44c747c" name="a1c62d9615acde55f57fcca92e44c747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c62d9615acde55f57fcca92e44c747c">&#9670;&#160;</a></span>try_emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#ac56bb654b47a648d64a754d85c70b40a">basic_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const Entity</td>          <td class="paramname"><span class="paramname"><em>entt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>force_back</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
    <tr><td class="paramname">force_back</td><td>Force back insertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the emplaced element. </dd></dl>

<p>Reimplemented in <a class="el" href="classentt_1_1basic__storage.html#a96a10490c949af09275a303e7d352f9a">entt::basic_storage&lt; Type, Entity, Allocator, typename &gt;</a>, <a class="el" href="classentt_1_1basic__storage_3_01_entity_00_01_entity_00_01_allocator_01_4.html#a70ee247f23204a7cd323968a19adf91e">entt::basic_storage&lt; Entity, Entity, Allocator &gt;</a>, and <a class="el" href="classentt_1_1basic__storage.html#a96a10490c949af09275a303e7d352f9a">entt::basic_storage&lt; Mask, Registry::entity_type, Allocator &gt;</a>.</p>

</div>
</div>
<a id="ae37830b84f2801670927b8ae881d72b7" name="ae37830b84f2801670927b8ae881d72b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37830b84f2801670927b8ae881d72b7">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structentt_1_1type__info.html">type_info</a> &amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returned value type, if any. </p>
<dl class="section return"><dt>Returns</dt><dd>Returned value type, if any. </dd></dl>

</div>
</div>
<a id="ab3725f4fb86b9bb73f5f397884ff1680" name="ab3725f4fb86b9bb73f5f397884ff1680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3725f4fb86b9bb73f5f397884ff1680">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element assigned to an entity, if any. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque pointer to the element assigned to the entity, if any. </dd></dl>

</div>
</div>
<a id="a319f3827fb68d33cddbdb5519723ea6f" name="a319f3827fb68d33cddbdb5519723ea6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319f3827fb68d33cddbdb5519723ea6f">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae90adeddf9bab1f9c8b4b1fff95980f0">entity_type</a></td>          <td class="paramname"><span class="paramname"><em>entt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element assigned to an entity, if any.    </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to use an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque pointer to the element assigned to the entity, if any.    </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="entt_8hpp_source.html">entt.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
