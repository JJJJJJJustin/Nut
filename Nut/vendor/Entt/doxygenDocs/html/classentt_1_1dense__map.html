<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>entt&#39;s architecture(Latest version 3.13.2): entt::dense_map&lt; Key, Type, Hash, KeyEqual, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">entt&#39;s architecture(Latest version 3.13.2)<span id="projectnumber">&#160;beta 0.1</span>
   </div>
   <div id="projectbrief">This is all details in entt.hpp</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>entt</b></li><li class="navelem"><a class="el" href="classentt_1_1dense__map.html">dense_map</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classentt_1_1dense__map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">entt::dense_map&lt; Key, Type, Hash, KeyEqual, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Associative container for key-value pairs with unique keys.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="entt_8hpp_source.html">entt.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb9e305df1fc9e886d6c761324dc15ab" id="r_aeb9e305df1fc9e886d6c761324dc15ab"><td class="memItemLeft" align="right" valign="top"><a id="aeb9e305df1fc9e886d6c761324dc15ab" name="aeb9e305df1fc9e886d6c761324dc15ab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = Key</td></tr>
<tr class="memdesc:aeb9e305df1fc9e886d6c761324dc15ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type of the container. <br /></td></tr>
<tr class="separator:aeb9e305df1fc9e886d6c761324dc15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdfe85f102518543b7a684c9e8e3bd3" id="r_a7cdfe85f102518543b7a684c9e8e3bd3"><td class="memItemLeft" align="right" valign="top"><a id="a7cdfe85f102518543b7a684c9e8e3bd3" name="a7cdfe85f102518543b7a684c9e8e3bd3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b> = Type</td></tr>
<tr class="memdesc:a7cdfe85f102518543b7a684c9e8e3bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapped type of the container. <br /></td></tr>
<tr class="separator:a7cdfe85f102518543b7a684c9e8e3bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53501af8bfd66b6bf45e8cfa844e180" id="r_aa53501af8bfd66b6bf45e8cfa844e180"><td class="memItemLeft" align="right" valign="top"><a id="aa53501af8bfd66b6bf45e8cfa844e180" name="aa53501af8bfd66b6bf45e8cfa844e180"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt;const Key, Type&gt;</td></tr>
<tr class="memdesc:aa53501af8bfd66b6bf45e8cfa844e180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value type of the container. <br /></td></tr>
<tr class="separator:aa53501af8bfd66b6bf45e8cfa844e180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ef651a1992486e3d2151e7829777f1" id="r_a38ef651a1992486e3d2151e7829777f1"><td class="memItemLeft" align="right" valign="top"><a id="a38ef651a1992486e3d2151e7829777f1" name="a38ef651a1992486e3d2151e7829777f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="memdesc:a38ef651a1992486e3d2151e7829777f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:a38ef651a1992486e3d2151e7829777f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62722d472417185388e952655b120e9" id="r_ae62722d472417185388e952655b120e9"><td class="memItemLeft" align="right" valign="top"><a id="ae62722d472417185388e952655b120e9" name="ae62722d472417185388e952655b120e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b> = Hash</td></tr>
<tr class="memdesc:ae62722d472417185388e952655b120e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of function to use to hash the keys. <br /></td></tr>
<tr class="separator:ae62722d472417185388e952655b120e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a26ee3be60abf7b5ecf16c99948086" id="r_a41a26ee3be60abf7b5ecf16c99948086"><td class="memItemLeft" align="right" valign="top"><a id="a41a26ee3be60abf7b5ecf16c99948086" name="a41a26ee3be60abf7b5ecf16c99948086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b> = KeyEqual</td></tr>
<tr class="memdesc:a41a26ee3be60abf7b5ecf16c99948086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of function to use to compare the keys for equality. <br /></td></tr>
<tr class="separator:a41a26ee3be60abf7b5ecf16c99948086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7feba2153b3764cc7789f31b926d78" id="r_adc7feba2153b3764cc7789f31b926d78"><td class="memItemLeft" align="right" valign="top"><a id="adc7feba2153b3764cc7789f31b926d78" name="adc7feba2153b3764cc7789f31b926d78"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = Allocator</td></tr>
<tr class="memdesc:adc7feba2153b3764cc7789f31b926d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type. <br /></td></tr>
<tr class="separator:adc7feba2153b3764cc7789f31b926d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc07b299f15a57db885089cc1a31322d" id="r_acc07b299f15a57db885089cc1a31322d"><td class="memItemLeft" align="right" valign="top"><a id="acc07b299f15a57db885089cc1a31322d" name="acc07b299f15a57db885089cc1a31322d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = internal::dense_map_iterator&lt;typename packed_container_type::iterator&gt;</td></tr>
<tr class="memdesc:acc07b299f15a57db885089cc1a31322d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input iterator type. <br /></td></tr>
<tr class="separator:acc07b299f15a57db885089cc1a31322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c236223418b9ef327397424e2df24f8" id="r_a5c236223418b9ef327397424e2df24f8"><td class="memItemLeft" align="right" valign="top"><a id="a5c236223418b9ef327397424e2df24f8" name="a5c236223418b9ef327397424e2df24f8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = internal::dense_map_iterator&lt;typename packed_container_type::const_iterator&gt;</td></tr>
<tr class="memdesc:a5c236223418b9ef327397424e2df24f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant input iterator type. <br /></td></tr>
<tr class="separator:a5c236223418b9ef327397424e2df24f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05e437f37f277cbe5c6121e67a4e89a" id="r_ad05e437f37f277cbe5c6121e67a4e89a"><td class="memItemLeft" align="right" valign="top"><a id="ad05e437f37f277cbe5c6121e67a4e89a" name="ad05e437f37f277cbe5c6121e67a4e89a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>local_iterator</b> = internal::dense_map_local_iterator&lt;typename packed_container_type::iterator&gt;</td></tr>
<tr class="memdesc:ad05e437f37f277cbe5c6121e67a4e89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input iterator type. <br /></td></tr>
<tr class="separator:ad05e437f37f277cbe5c6121e67a4e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad699469dc43bfd00d9ea86c686afb394" id="r_ad699469dc43bfd00d9ea86c686afb394"><td class="memItemLeft" align="right" valign="top"><a id="ad699469dc43bfd00d9ea86c686afb394" name="ad699469dc43bfd00d9ea86c686afb394"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_local_iterator</b> = internal::dense_map_local_iterator&lt;typename packed_container_type::const_iterator&gt;</td></tr>
<tr class="memdesc:ad699469dc43bfd00d9ea86c686afb394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant input iterator type. <br /></td></tr>
<tr class="separator:ad699469dc43bfd00d9ea86c686afb394"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af163bec2cf56f3571000a5fc0145832f" id="r_af163bec2cf56f3571000a5fc0145832f"><td class="memItemLeft" align="right" valign="top"><a id="af163bec2cf56f3571000a5fc0145832f" name="af163bec2cf56f3571000a5fc0145832f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dense_map</b> ()</td></tr>
<tr class="memdesc:af163bec2cf56f3571000a5fc0145832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af163bec2cf56f3571000a5fc0145832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096357c0bdb6342d7d304716e41fcea5" id="r_a096357c0bdb6342d7d304716e41fcea5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096357c0bdb6342d7d304716e41fcea5">dense_map</a> (const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a096357c0bdb6342d7d304716e41fcea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator.  <br /></td></tr>
<tr class="separator:a096357c0bdb6342d7d304716e41fcea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c65b19c282b4a2bce0434facca4c5" id="r_a524c65b19c282b4a2bce0434facca4c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a524c65b19c282b4a2bce0434facca4c5">dense_map</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> cnt, const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a524c65b19c282b4a2bce0434facca4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator and user supplied minimal number of buckets.  <br /></td></tr>
<tr class="separator:a524c65b19c282b4a2bce0434facca4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47beb8b4689e0e09e7527bd537f69b" id="r_acb47beb8b4689e0e09e7527bd537f69b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb47beb8b4689e0e09e7527bd537f69b">dense_map</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> cnt, const <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &amp;hash, const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:acb47beb8b4689e0e09e7527bd537f69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator, hash function and user supplied minimal number of buckets.  <br /></td></tr>
<tr class="separator:acb47beb8b4689e0e09e7527bd537f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07183a6c046d3a3b2e7201bd63aa8efe" id="r_a07183a6c046d3a3b2e7201bd63aa8efe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07183a6c046d3a3b2e7201bd63aa8efe">dense_map</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> cnt, const <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &amp;hash=<a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a>{}, const <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &amp;equal=<a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a>{}, const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator=<a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a>{})</td></tr>
<tr class="memdesc:a07183a6c046d3a3b2e7201bd63aa8efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with a given allocator, hash function, compare function and user supplied minimal number of buckets.  <br /></td></tr>
<tr class="separator:a07183a6c046d3a3b2e7201bd63aa8efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa72d92d87e8020e0ca5f035cd665d8b" id="r_aaa72d92d87e8020e0ca5f035cd665d8b"><td class="memItemLeft" align="right" valign="top"><a id="aaa72d92d87e8020e0ca5f035cd665d8b" name="aaa72d92d87e8020e0ca5f035cd665d8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dense_map</b> (const <a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;)=default</td></tr>
<tr class="memdesc:aaa72d92d87e8020e0ca5f035cd665d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:aaa72d92d87e8020e0ca5f035cd665d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8924f4faaa1879a84734ec58f11e6662" id="r_a8924f4faaa1879a84734ec58f11e6662"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8924f4faaa1879a84734ec58f11e6662">dense_map</a> (const <a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;other, const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a8924f4faaa1879a84734ec58f11e6662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended copy constructor.  <br /></td></tr>
<tr class="separator:a8924f4faaa1879a84734ec58f11e6662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8a1c7ef883881e6b9597de923e348b" id="r_aff8a1c7ef883881e6b9597de923e348b"><td class="memItemLeft" align="right" valign="top"><a id="aff8a1c7ef883881e6b9597de923e348b" name="aff8a1c7ef883881e6b9597de923e348b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dense_map</b> (<a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;&amp;) noexcept(std::is_nothrow_move_constructible_v&lt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; sparse_container_type, <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &gt; &amp;&amp;std::is_nothrow_move_constructible_v&lt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; packed_container_type, <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt; &gt;)=default</td></tr>
<tr class="memdesc:aff8a1c7ef883881e6b9597de923e348b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:aff8a1c7ef883881e6b9597de923e348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352da8efacf3d89715b5892e65b82f66" id="r_a352da8efacf3d89715b5892e65b82f66"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352da8efacf3d89715b5892e65b82f66">dense_map</a> (<a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;&amp;other, const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a352da8efacf3d89715b5892e65b82f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <br /></td></tr>
<tr class="separator:a352da8efacf3d89715b5892e65b82f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee333a078e7bc2b1035a911aff3b7ed" id="r_a6ee333a078e7bc2b1035a911aff3b7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee333a078e7bc2b1035a911aff3b7ed">operator=</a> (const <a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;)=default</td></tr>
<tr class="memdesc:a6ee333a078e7bc2b1035a911aff3b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <br /></td></tr>
<tr class="separator:a6ee333a078e7bc2b1035a911aff3b7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc4fceb8b438a1eeea0ee95f7885d60" id="r_aadc4fceb8b438a1eeea0ee95f7885d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadc4fceb8b438a1eeea0ee95f7885d60">operator=</a> (<a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;&amp;) noexcept(std::is_nothrow_move_assignable_v&lt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; sparse_container_type, <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &gt; &amp;&amp;std::is_nothrow_move_assignable_v&lt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; packed_container_type, <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt; &gt;)=default</td></tr>
<tr class="memdesc:aadc4fceb8b438a1eeea0ee95f7885d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator.  <br /></td></tr>
<tr class="separator:aadc4fceb8b438a1eeea0ee95f7885d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd5632c26bf5281cfbbd7fbd9f85bf5" id="r_a9cd5632c26bf5281cfbbd7fbd9f85bf5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cd5632c26bf5281cfbbd7fbd9f85bf5">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a9cd5632c26bf5281cfbbd7fbd9f85bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the associated allocator.  <br /></td></tr>
<tr class="separator:a9cd5632c26bf5281cfbbd7fbd9f85bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cef5e32d1e4575669c9afcf6bcbedc5" id="r_a2cef5e32d1e4575669c9afcf6bcbedc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cef5e32d1e4575669c9afcf6bcbedc5">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a2cef5e32d1e4575669c9afcf6bcbedc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="separator:a2cef5e32d1e4575669c9afcf6bcbedc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0e7de10687bc1e810d67ba6a91396d" id="r_a7c0e7de10687bc1e810d67ba6a91396d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0e7de10687bc1e810d67ba6a91396d">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a7c0e7de10687bc1e810d67ba6a91396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.     <br /></td></tr>
<tr class="separator:a7c0e7de10687bc1e810d67ba6a91396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f0ff4d0988673a027ac0e0348b216" id="r_afb7f0ff4d0988673a027ac0e0348b216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb7f0ff4d0988673a027ac0e0348b216">begin</a> () noexcept</td></tr>
<tr class="memdesc:afb7f0ff4d0988673a027ac0e0348b216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.        <br /></td></tr>
<tr class="separator:afb7f0ff4d0988673a027ac0e0348b216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5123c811e7090df1a793e9bc1821d2e5" id="r_a5123c811e7090df1a793e9bc1821d2e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5123c811e7090df1a793e9bc1821d2e5">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a5123c811e7090df1a793e9bc1821d2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="separator:a5123c811e7090df1a793e9bc1821d2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa80b6dff4ba1f455fabec3ff197e8c5" id="r_afa80b6dff4ba1f455fabec3ff197e8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa80b6dff4ba1f455fabec3ff197e8c5">end</a> () const noexcept</td></tr>
<tr class="memdesc:afa80b6dff4ba1f455fabec3ff197e8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.     <br /></td></tr>
<tr class="separator:afa80b6dff4ba1f455fabec3ff197e8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4ff12e8b032e6ca5519557d07d1178" id="r_afd4ff12e8b032e6ca5519557d07d1178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd4ff12e8b032e6ca5519557d07d1178">end</a> () noexcept</td></tr>
<tr class="memdesc:afd4ff12e8b032e6ca5519557d07d1178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.        <br /></td></tr>
<tr class="separator:afd4ff12e8b032e6ca5519557d07d1178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f1227e06bf48744b46b3fe251d72f2" id="r_ad6f1227e06bf48744b46b3fe251d72f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6f1227e06bf48744b46b3fe251d72f2">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ad6f1227e06bf48744b46b3fe251d72f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a container is empty.  <br /></td></tr>
<tr class="separator:ad6f1227e06bf48744b46b3fe251d72f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b10511f585724b7eb6e5f9556dea21" id="r_a38b10511f585724b7eb6e5f9556dea21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b10511f585724b7eb6e5f9556dea21">size</a> () const noexcept</td></tr>
<tr class="memdesc:a38b10511f585724b7eb6e5f9556dea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a container.  <br /></td></tr>
<tr class="separator:a38b10511f585724b7eb6e5f9556dea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45843ecba66cc9692ae4facac5461e4d" id="r_a45843ecba66cc9692ae4facac5461e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45843ecba66cc9692ae4facac5461e4d">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a45843ecba66cc9692ae4facac5461e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements.  <br /></td></tr>
<tr class="separator:a45843ecba66cc9692ae4facac5461e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c30be0af8e15902f5585c8d1208b7" id="r_a096c30be0af8e15902f5585c8d1208b7"><td class="memItemLeft" align="right" valign="top"><a id="a096c30be0af8e15902f5585c8d1208b7" name="a096c30be0af8e15902f5585c8d1208b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:a096c30be0af8e15902f5585c8d1208b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container. <br /></td></tr>
<tr class="separator:a096c30be0af8e15902f5585c8d1208b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4ac1f5a3295d80d8bb4fa6387023db" id="r_ada4ac1f5a3295d80d8bb4fa6387023db"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4ac1f5a3295d80d8bb4fa6387023db">insert</a> (const <a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:ada4ac1f5a3295d80d8bb4fa6387023db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the container, if the key does not exist.  <br /></td></tr>
<tr class="separator:ada4ac1f5a3295d80d8bb4fa6387023db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e1a562a523572405bbf0a53bb8535d" id="r_a71e1a562a523572405bbf0a53bb8535d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71e1a562a523572405bbf0a53bb8535d">insert</a> (<a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a71e1a562a523572405bbf0a53bb8535d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the container, if the key does not exist.     <br /></td></tr>
<tr class="separator:a71e1a562a523572405bbf0a53bb8535d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eced5574b8354b8357f79faf16fc23" id="r_a92eced5574b8354b8357f79faf16fc23"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a92eced5574b8354b8357f79faf16fc23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_constructible_v&lt; <a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a>, Arg &amp;&amp; &gt;, std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92eced5574b8354b8357f79faf16fc23">insert</a> (Arg &amp;&amp;value)</td></tr>
<tr class="memdesc:a92eced5574b8354b8357f79faf16fc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the container, if the key does not exist.     <br /></td></tr>
<tr class="separator:a92eced5574b8354b8357f79faf16fc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94e139b8d65ac65df36161183a8a49" id="r_a3c94e139b8d65ac65df36161183a8a49"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a3c94e139b8d65ac65df36161183a8a49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c94e139b8d65ac65df36161183a8a49">insert</a> (It first, It last)</td></tr>
<tr class="memdesc:a3c94e139b8d65ac65df36161183a8a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements into the container, if their keys do not exist.  <br /></td></tr>
<tr class="separator:a3c94e139b8d65ac65df36161183a8a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafff57a203cd3fc561320bad6eeea0c3" id="r_aafff57a203cd3fc561320bad6eeea0c3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aafff57a203cd3fc561320bad6eeea0c3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafff57a203cd3fc561320bad6eeea0c3">insert_or_assign</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key, Arg &amp;&amp;value)</td></tr>
<tr class="memdesc:aafff57a203cd3fc561320bad6eeea0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the container or assigns to the current element if the key already exists.  <br /></td></tr>
<tr class="separator:aafff57a203cd3fc561320bad6eeea0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9522dcd518bd3d73769d80d35606db" id="r_a9a9522dcd518bd3d73769d80d35606db"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a9a9522dcd518bd3d73769d80d35606db"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a9522dcd518bd3d73769d80d35606db">insert_or_assign</a> (<a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;key, Arg &amp;&amp;value)</td></tr>
<tr class="memdesc:a9a9522dcd518bd3d73769d80d35606db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into the container or assigns to the current element if the key already exists.     <br /></td></tr>
<tr class="separator:a9a9522dcd518bd3d73769d80d35606db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dfc292981ab6694cd4609879a80dbc" id="r_ab0dfc292981ab6694cd4609879a80dbc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab0dfc292981ab6694cd4609879a80dbc"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0dfc292981ab6694cd4609879a80dbc">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab0dfc292981ab6694cd4609879a80dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element in-place, if the key does not exist.  <br /></td></tr>
<tr class="separator:ab0dfc292981ab6694cd4609879a80dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53111b5614ea1d29d8396279ebfd7d3e" id="r_a53111b5614ea1d29d8396279ebfd7d3e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a53111b5614ea1d29d8396279ebfd7d3e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53111b5614ea1d29d8396279ebfd7d3e">try_emplace</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a53111b5614ea1d29d8396279ebfd7d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.  <br /></td></tr>
<tr class="separator:a53111b5614ea1d29d8396279ebfd7d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0e98c01ad728022e5388535333fb1" id="r_ab2b0e98c01ad728022e5388535333fb1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab2b0e98c01ad728022e5388535333fb1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2b0e98c01ad728022e5388535333fb1">try_emplace</a> (<a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab2b0e98c01ad728022e5388535333fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts in-place if the key does not exist, does nothing if the key exists.     <br /></td></tr>
<tr class="separator:ab2b0e98c01ad728022e5388535333fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83036e3f167d28ba9afa943271fb5587" id="r_a83036e3f167d28ba9afa943271fb5587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83036e3f167d28ba9afa943271fb5587">erase</a> (<a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a83036e3f167d28ba9afa943271fb5587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a given position.  <br /></td></tr>
<tr class="separator:a83036e3f167d28ba9afa943271fb5587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb9a8de8e27cff97395d4fc527ad04" id="r_a49bb9a8de8e27cff97395d4fc527ad04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49bb9a8de8e27cff97395d4fc527ad04">erase</a> (<a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> first, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> last)</td></tr>
<tr class="memdesc:a49bb9a8de8e27cff97395d4fc527ad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given elements from a container.  <br /></td></tr>
<tr class="separator:a49bb9a8de8e27cff97395d4fc527ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1730a14bac304cbd173c05cb2cbf2" id="r_a12d1730a14bac304cbd173c05cb2cbf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12d1730a14bac304cbd173c05cb2cbf2">erase</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a12d1730a14bac304cbd173c05cb2cbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element associated with a given key.  <br /></td></tr>
<tr class="separator:a12d1730a14bac304cbd173c05cb2cbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88e2ffe045acc9aef1de4f77a23449b" id="r_ab88e2ffe045acc9aef1de4f77a23449b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab88e2ffe045acc9aef1de4f77a23449b">swap</a> (<a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp;other)</td></tr>
<tr class="memdesc:ab88e2ffe045acc9aef1de4f77a23449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents with those of a given container.  <br /></td></tr>
<tr class="separator:ab88e2ffe045acc9aef1de4f77a23449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468bf103c5f4779ee24d002576150689" id="r_a468bf103c5f4779ee24d002576150689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a468bf103c5f4779ee24d002576150689">at</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a468bf103c5f4779ee24d002576150689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a given element with bounds checking.  <br /></td></tr>
<tr class="separator:a468bf103c5f4779ee24d002576150689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413f21b4eee0336277f24de044fe8cb6" id="r_a413f21b4eee0336277f24de044fe8cb6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413f21b4eee0336277f24de044fe8cb6">at</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a413f21b4eee0336277f24de044fe8cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a given element with bounds checking.     <br /></td></tr>
<tr class="separator:a413f21b4eee0336277f24de044fe8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5784ca7ce9ab1ea46b303598f9987d" id="r_a9b5784ca7ce9ab1ea46b303598f9987d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b5784ca7ce9ab1ea46b303598f9987d">operator[]</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a9b5784ca7ce9ab1ea46b303598f9987d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses or inserts a given element.  <br /></td></tr>
<tr class="separator:a9b5784ca7ce9ab1ea46b303598f9987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e0c8cdb0eef57582ce061a631b0a56" id="r_a19e0c8cdb0eef57582ce061a631b0a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e0c8cdb0eef57582ce061a631b0a56">operator[]</a> (<a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;key)</td></tr>
<tr class="memdesc:a19e0c8cdb0eef57582ce061a631b0a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses or inserts a given element.  <br /></td></tr>
<tr class="separator:a19e0c8cdb0eef57582ce061a631b0a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5f56217b3b8eae9ad34334df1a931d" id="r_a4b5f56217b3b8eae9ad34334df1a931d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5f56217b3b8eae9ad34334df1a931d">count</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a4b5f56217b3b8eae9ad34334df1a931d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements matching a key (either 1 or 0).  <br /></td></tr>
<tr class="separator:a4b5f56217b3b8eae9ad34334df1a931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3858017ba66ff9989fe2427065dd6d97" id="r_a3858017ba66ff9989fe2427065dd6d97"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3858017ba66ff9989fe2427065dd6d97"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3858017ba66ff9989fe2427065dd6d97">count</a> (const Other &amp;key) const</td></tr>
<tr class="memdesc:a3858017ba66ff9989fe2427065dd6d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements matching a key (either 1 or 0).  <br /></td></tr>
<tr class="separator:a3858017ba66ff9989fe2427065dd6d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aa062268245a84c4c27dcc01839814" id="r_a77aa062268245a84c4c27dcc01839814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77aa062268245a84c4c27dcc01839814">find</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a77aa062268245a84c4c27dcc01839814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with a given key.  <br /></td></tr>
<tr class="separator:a77aa062268245a84c4c27dcc01839814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b47e5c447352298fca87921774c4a3d" id="r_a5b47e5c447352298fca87921774c4a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b47e5c447352298fca87921774c4a3d">find</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a5b47e5c447352298fca87921774c4a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with a given key.     <br /></td></tr>
<tr class="separator:a5b47e5c447352298fca87921774c4a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf771ba10ee17109769cecd68f0991c5" id="r_abf771ba10ee17109769cecd68f0991c5"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:abf771ba10ee17109769cecd68f0991c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf771ba10ee17109769cecd68f0991c5">find</a> (const Other &amp;key)</td></tr>
<tr class="memdesc:abf771ba10ee17109769cecd68f0991c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with a key that compares <em>equivalent</em> to a given key.  <br /></td></tr>
<tr class="separator:abf771ba10ee17109769cecd68f0991c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c611a71d59737c941b1aaf29e64c9b7" id="r_a4c611a71d59737c941b1aaf29e64c9b7"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a4c611a71d59737c941b1aaf29e64c9b7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c611a71d59737c941b1aaf29e64c9b7">find</a> (const Other &amp;key) const</td></tr>
<tr class="memdesc:a4c611a71d59737c941b1aaf29e64c9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with a given key.     <br /></td></tr>
<tr class="separator:a4c611a71d59737c941b1aaf29e64c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b33cb48b4784e336d87246701b2024" id="r_a77b33cb48b4784e336d87246701b2024"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b33cb48b4784e336d87246701b2024">equal_range</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a77b33cb48b4784e336d87246701b2024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with a given key.  <br /></td></tr>
<tr class="separator:a77b33cb48b4784e336d87246701b2024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76ed82791a0f50d0f7aa0bcec46105b" id="r_af76ed82791a0f50d0f7aa0bcec46105b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af76ed82791a0f50d0f7aa0bcec46105b">equal_range</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:af76ed82791a0f50d0f7aa0bcec46105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with a given key.     <br /></td></tr>
<tr class="separator:af76ed82791a0f50d0f7aa0bcec46105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d747a3b187a97814603e41ad37bf26e" id="r_a3d747a3b187a97814603e41ad37bf26e"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3d747a3b187a97814603e41ad37bf26e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d747a3b187a97814603e41ad37bf26e">equal_range</a> (const Other &amp;key)</td></tr>
<tr class="memdesc:a3d747a3b187a97814603e41ad37bf26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements that compare <em>equivalent</em> to a given key.  <br /></td></tr>
<tr class="separator:a3d747a3b187a97814603e41ad37bf26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973f2399943dc681e617bb8b46e9244c" id="r_a973f2399943dc681e617bb8b46e9244c"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a973f2399943dc681e617bb8b46e9244c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, std::pair&lt; <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a973f2399943dc681e617bb8b46e9244c">equal_range</a> (const Other &amp;key) const</td></tr>
<tr class="memdesc:a973f2399943dc681e617bb8b46e9244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with a given key.     <br /></td></tr>
<tr class="separator:a973f2399943dc681e617bb8b46e9244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d884a2b7164b3df97d93dd2804222b0" id="r_a4d884a2b7164b3df97d93dd2804222b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d884a2b7164b3df97d93dd2804222b0">contains</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a4d884a2b7164b3df97d93dd2804222b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains an element with a given key.  <br /></td></tr>
<tr class="separator:a4d884a2b7164b3df97d93dd2804222b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be7fc1cde4a3ae47f22333e3220200" id="r_a20be7fc1cde4a3ae47f22333e3220200"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a20be7fc1cde4a3ae47f22333e3220200"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, bool &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20be7fc1cde4a3ae47f22333e3220200">contains</a> (const Other &amp;key) const</td></tr>
<tr class="memdesc:a20be7fc1cde4a3ae47f22333e3220200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container contains an element with a key that compares <em>equivalent</em> to a given value.  <br /></td></tr>
<tr class="separator:a20be7fc1cde4a3ae47f22333e3220200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9beebb937e95a40246455194c86c84" id="r_a9e9beebb937e95a40246455194c86c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e9beebb937e95a40246455194c86c84">cbegin</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index) const</td></tr>
<tr class="memdesc:a9e9beebb937e95a40246455194c86c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of a given bucket.  <br /></td></tr>
<tr class="separator:a9e9beebb937e95a40246455194c86c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33900c670781f415f4eb0bfeb5be04a3" id="r_a33900c670781f415f4eb0bfeb5be04a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33900c670781f415f4eb0bfeb5be04a3">begin</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index) const</td></tr>
<tr class="memdesc:a33900c670781f415f4eb0bfeb5be04a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of a given bucket.  <br /></td></tr>
<tr class="separator:a33900c670781f415f4eb0bfeb5be04a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71476135fb7147c02ec7a801564c72" id="r_a4b71476135fb7147c02ec7a801564c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad05e437f37f277cbe5c6121e67a4e89a">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b71476135fb7147c02ec7a801564c72">begin</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index)</td></tr>
<tr class="memdesc:a4b71476135fb7147c02ec7a801564c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of a given bucket.  <br /></td></tr>
<tr class="separator:a4b71476135fb7147c02ec7a801564c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8125ea2706a6208565a4d67f0e6efbed" id="r_a8125ea2706a6208565a4d67f0e6efbed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8125ea2706a6208565a4d67f0e6efbed">cend</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index) const</td></tr>
<tr class="memdesc:a8125ea2706a6208565a4d67f0e6efbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of a given bucket.  <br /></td></tr>
<tr class="separator:a8125ea2706a6208565a4d67f0e6efbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c36baa7b9aa7df7d3a07ca090319328" id="r_a3c36baa7b9aa7df7d3a07ca090319328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c36baa7b9aa7df7d3a07ca090319328">end</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index) const</td></tr>
<tr class="memdesc:a3c36baa7b9aa7df7d3a07ca090319328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of a given bucket.  <br /></td></tr>
<tr class="separator:a3c36baa7b9aa7df7d3a07ca090319328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab971fb709972a0e26b95e4fdb89aa64e" id="r_ab971fb709972a0e26b95e4fdb89aa64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad05e437f37f277cbe5c6121e67a4e89a">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab971fb709972a0e26b95e4fdb89aa64e">end</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index)</td></tr>
<tr class="memdesc:ab971fb709972a0e26b95e4fdb89aa64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of a given bucket.  <br /></td></tr>
<tr class="separator:ab971fb709972a0e26b95e4fdb89aa64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee246b41534137f279a11eb5e225a6e5" id="r_aee246b41534137f279a11eb5e225a6e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee246b41534137f279a11eb5e225a6e5">bucket_count</a> () const</td></tr>
<tr class="memdesc:aee246b41534137f279a11eb5e225a6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buckets.  <br /></td></tr>
<tr class="separator:aee246b41534137f279a11eb5e225a6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4818548e35a239228a5fae77af01e7f5" id="r_a4818548e35a239228a5fae77af01e7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4818548e35a239228a5fae77af01e7f5">max_bucket_count</a> () const</td></tr>
<tr class="memdesc:a4818548e35a239228a5fae77af01e7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of buckets.  <br /></td></tr>
<tr class="separator:a4818548e35a239228a5fae77af01e7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae094f65cda09d80851306f6a4bba7b50" id="r_ae094f65cda09d80851306f6a4bba7b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae094f65cda09d80851306f6a4bba7b50">bucket_size</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> index) const</td></tr>
<tr class="memdesc:ae094f65cda09d80851306f6a4bba7b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a given bucket.  <br /></td></tr>
<tr class="separator:ae094f65cda09d80851306f6a4bba7b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a591d419dd5649e52907a3032f8c0b8" id="r_a9a591d419dd5649e52907a3032f8c0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a591d419dd5649e52907a3032f8c0b8">bucket</a> (const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a9a591d419dd5649e52907a3032f8c0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bucket for a given key.  <br /></td></tr>
<tr class="separator:a9a591d419dd5649e52907a3032f8c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd2095ae61e1908572efa33dc3df56" id="r_a0ebd2095ae61e1908572efa33dc3df56"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ebd2095ae61e1908572efa33dc3df56">load_factor</a> () const</td></tr>
<tr class="memdesc:a0ebd2095ae61e1908572efa33dc3df56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average number of elements per bucket.  <br /></td></tr>
<tr class="separator:a0ebd2095ae61e1908572efa33dc3df56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a2dd65d401a992fd91fb8a91faea86" id="r_a54a2dd65d401a992fd91fb8a91faea86"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54a2dd65d401a992fd91fb8a91faea86">max_load_factor</a> () const</td></tr>
<tr class="memdesc:a54a2dd65d401a992fd91fb8a91faea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum average number of elements per bucket.  <br /></td></tr>
<tr class="separator:a54a2dd65d401a992fd91fb8a91faea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608539db499acbc3a7548421ea5d8709" id="r_a608539db499acbc3a7548421ea5d8709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608539db499acbc3a7548421ea5d8709">max_load_factor</a> (const float value)</td></tr>
<tr class="memdesc:a608539db499acbc3a7548421ea5d8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the desired maximum average number of elements per bucket.  <br /></td></tr>
<tr class="separator:a608539db499acbc3a7548421ea5d8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cea2e02e86eec9421ddaab64f15db6b" id="r_a7cea2e02e86eec9421ddaab64f15db6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cea2e02e86eec9421ddaab64f15db6b">rehash</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> cnt)</td></tr>
<tr class="memdesc:a7cea2e02e86eec9421ddaab64f15db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves at least the specified number of buckets and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a7cea2e02e86eec9421ddaab64f15db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47084f57549451518ef81a0f7cbdae0e" id="r_a47084f57549451518ef81a0f7cbdae0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47084f57549451518ef81a0f7cbdae0e">reserve</a> (const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> cnt)</td></tr>
<tr class="memdesc:a47084f57549451518ef81a0f7cbdae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for at least the specified number of elements and regenerates the hash table.  <br /></td></tr>
<tr class="separator:a47084f57549451518ef81a0f7cbdae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1426bfb2ff55c9c4d0471303fcf6cc" id="r_afa1426bfb2ff55c9c4d0471303fcf6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1426bfb2ff55c9c4d0471303fcf6cc">hash_function</a> () const</td></tr>
<tr class="memdesc:afa1426bfb2ff55c9c4d0471303fcf6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function used to hash the keys.  <br /></td></tr>
<tr class="separator:afa1426bfb2ff55c9c4d0471303fcf6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2039886ad16466a4f9928dc737cd711" id="r_ac2039886ad16466a4f9928dc737cd711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2039886ad16466a4f9928dc737cd711">key_eq</a> () const</td></tr>
<tr class="memdesc:ac2039886ad16466a4f9928dc737cd711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function used to compare keys for equality.  <br /></td></tr>
<tr class="separator:ac2039886ad16466a4f9928dc737cd711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Type, typename Hash, typename KeyEqual, typename Allocator&gt;<br />
class entt::dense_map&lt; Key, Type, Hash, KeyEqual, Allocator &gt;</div><p>Associative container for key-value pairs with unique keys. </p>
<p>Internally, elements are organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. Keys with the same hash code appear in the same bucket.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type of the associative container. </td></tr>
    <tr><td class="paramname">Type</td><td>Mapped type of the associative container. </td></tr>
    <tr><td class="paramname">Hash</td><td>Type of function to use to hash the keys. </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>Type of function to use to compare the keys for equality. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a096357c0bdb6342d7d304716e41fcea5" name="a096357c0bdb6342d7d304716e41fcea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096357c0bdb6342d7d304716e41fcea5">&#9670;&#160;</a></span>dense_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a524c65b19c282b4a2bce0434facca4c5" name="a524c65b19c282b4a2bce0434facca4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524c65b19c282b4a2bce0434facca4c5">&#9670;&#160;</a></span>dense_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator and user supplied minimal number of buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Minimal number of buckets. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb47beb8b4689e0e09e7527bd537f69b" name="acb47beb8b4689e0e09e7527bd537f69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb47beb8b4689e0e09e7527bd537f69b">&#9670;&#160;</a></span>dense_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator, hash function and user supplied minimal number of buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Minimal number of buckets. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07183a6c046d3a3b2e7201bd63aa8efe" name="a07183a6c046d3a3b2e7201bd63aa8efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07183a6c046d3a3b2e7201bd63aa8efe">&#9670;&#160;</a></span>dense_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a>{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>equal</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a>{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a>{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with a given allocator, hash function, compare function and user supplied minimal number of buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Minimal number of buckets. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash function to use. </td></tr>
    <tr><td class="paramname">equal</td><td>Compare function to use. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8924f4faaa1879a84734ec58f11e6662" name="a8924f4faaa1879a84734ec58f11e6662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8924f4faaa1879a84734ec58f11e6662">&#9670;&#160;</a></span>dense_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1dense__map.html">dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to copy from. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a352da8efacf3d89715b5892e65b82f66" name="a352da8efacf3d89715b5892e65b82f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352da8efacf3d89715b5892e65b82f66">&#9670;&#160;</a></span>dense_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::dense_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1dense__map.html">dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a468bf103c5f4779ee24d002576150689" name="a468bf103c5f4779ee24d002576150689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468bf103c5f4779ee24d002576150689">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses a given element with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of an element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a413f21b4eee0336277f24de044fe8cb6" name="a413f21b4eee0336277f24de044fe8cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413f21b4eee0336277f24de044fe8cb6">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses a given element with bounds checking.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of an element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element.    </dd></dl>

</div>
</div>
<a id="a7c0e7de10687bc1e810d67ba6a91396d" name="a7c0e7de10687bc1e810d67ba6a91396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0e7de10687bc1e810d67ba6a91396d">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.    </p>
<p>If the array is empty, the returned iterator will be equal to <code><a class="el" href="#afa80b6dff4ba1f455fabec3ff197e8c5" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the internal array.    </dd></dl>

</div>
</div>
<a id="afb7f0ff4d0988673a027ac0e0348b216" name="afb7f0ff4d0988673a027ac0e0348b216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f0ff4d0988673a027ac0e0348b216">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning.       </p>
<p>If the array is empty, the returned iterator will be equal to <code><a class="el" href="#afa80b6dff4ba1f455fabec3ff197e8c5" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the internal array.       </dd></dl>

</div>
</div>
<a id="a4b71476135fb7147c02ec7a801564c72" name="a4b71476135fb7147c02ec7a801564c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b71476135fb7147c02ec7a801564c72">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad05e437f37f277cbe5c6121e67a4e89a">local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the given bucket. </dd></dl>

</div>
</div>
<a id="a33900c670781f415f4eb0bfeb5be04a3" name="a33900c670781f415f4eb0bfeb5be04a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33900c670781f415f4eb0bfeb5be04a3">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the given bucket. </dd></dl>

</div>
</div>
<a id="a9a591d419dd5649e52907a3032f8c0b8" name="a9a591d419dd5649e52907a3032f8c0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a591d419dd5649e52907a3032f8c0b8">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bucket for a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value of the key to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bucket for the given key. </dd></dl>

</div>
</div>
<a id="aee246b41534137f279a11eb5e225a6e5" name="aee246b41534137f279a11eb5e225a6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee246b41534137f279a11eb5e225a6e5">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buckets. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buckets. </dd></dl>

</div>
</div>
<a id="ae094f65cda09d80851306f6a4bba7b50" name="ae094f65cda09d80851306f6a4bba7b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae094f65cda09d80851306f6a4bba7b50">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the bucket to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the given bucket. </dd></dl>

</div>
</div>
<a id="a2cef5e32d1e4575669c9afcf6bcbedc5" name="a2cef5e32d1e4575669c9afcf6bcbedc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cef5e32d1e4575669c9afcf6bcbedc5">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>If the array is empty, the returned iterator will be equal to <code><a class="el" href="#afa80b6dff4ba1f455fabec3ff197e8c5" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first instance of the internal array. </dd></dl>

</div>
</div>
<a id="a9e9beebb937e95a40246455194c86c84" name="a9e9beebb937e95a40246455194c86c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9beebb937e95a40246455194c86c84">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the given bucket. </dd></dl>

</div>
</div>
<a id="a5123c811e7090df1a793e9bc1821d2e5" name="a5123c811e7090df1a793e9bc1821d2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5123c811e7090df1a793e9bc1821d2e5">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the internal array. </dd></dl>

</div>
</div>
<a id="a8125ea2706a6208565a4d67f0e6efbed" name="a8125ea2706a6208565a4d67f0e6efbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8125ea2706a6208565a4d67f0e6efbed">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the given bucket. </dd></dl>

</div>
</div>
<a id="a4d884a2b7164b3df97d93dd2804222b0" name="a4d884a2b7164b3df97d93dd2804222b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d884a2b7164b3df97d93dd2804222b0">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains an element with a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is such an element, false otherwise. </dd></dl>

</div>
</div>
<a id="a20be7fc1cde4a3ae47f22333e3220200" name="a20be7fc1cde4a3ae47f22333e3220200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be7fc1cde4a3ae47f22333e3220200">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, bool &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container contains an element with a key that compares <em>equivalent</em> to a given value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Type of the key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is such an element, false otherwise. </dd></dl>

</div>
</div>
<a id="a4b5f56217b3b8eae9ad34334df1a931d" name="a4b5f56217b3b8eae9ad34334df1a931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5f56217b3b8eae9ad34334df1a931d">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements matching a key (either 1 or 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements matching the key (either 1 or 0). </dd></dl>

</div>
</div>
<a id="a3858017ba66ff9989fe2427065dd6d97" name="a3858017ba66ff9989fe2427065dd6d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3858017ba66ff9989fe2427065dd6d97">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements matching a key (either 1 or 0). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Type of the key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements matching the key (either 1 or 0). </dd></dl>

</div>
</div>
<a id="ab0dfc292981ab6694cd4609879a80dbc" name="ab0dfc292981ab6694cd4609879a80dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dfc292981ab6694cd4609879a80dbc">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element in-place, if the key does not exist. </p>
<p>The element is also constructed when the container already has the key, in which case the newly constructed object is destroyed immediately.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. </dd></dl>

</div>
</div>
<a id="ad6f1227e06bf48744b46b3fe251d72f2" name="ad6f1227e06bf48744b46b3fe251d72f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f1227e06bf48744b46b3fe251d72f2">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the container is empty, false otherwise. </dd></dl>

</div>
</div>
<a id="afa80b6dff4ba1f455fabec3ff197e8c5" name="afa80b6dff4ba1f455fabec3ff197e8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa80b6dff4ba1f455fabec3ff197e8c5">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.    </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the internal array.    </dd></dl>

</div>
</div>
<a id="afd4ff12e8b032e6ca5519557d07d1178" name="afd4ff12e8b032e6ca5519557d07d1178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4ff12e8b032e6ca5519557d07d1178">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end.       </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last instance of the internal array.       </dd></dl>

</div>
</div>
<a id="ab971fb709972a0e26b95e4fdb89aa64e" name="ab971fb709972a0e26b95e4fdb89aa64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab971fb709972a0e26b95e4fdb89aa64e">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad05e437f37f277cbe5c6121e67a4e89a">local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the given bucket. </dd></dl>

</div>
</div>
<a id="a3c36baa7b9aa7df7d3a07ca090319328" name="a3c36baa7b9aa7df7d3a07ca090319328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c36baa7b9aa7df7d3a07ca090319328">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad699469dc43bfd00d9ea86c686afb394">const_local_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of a given bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index of a bucket to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the given bucket. </dd></dl>

</div>
</div>
<a id="a77b33cb48b4784e336d87246701b2024" name="a77b33cb48b4784e336d87246701b2024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b33cb48b4784e336d87246701b2024">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first element and past the last element of the range. </dd></dl>

</div>
</div>
<a id="af76ed82791a0f50d0f7aa0bcec46105b" name="af76ed82791a0f50d0f7aa0bcec46105b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76ed82791a0f50d0f7aa0bcec46105b">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with a given key.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first element and past the last element of the range.    </dd></dl>

</div>
</div>
<a id="a3d747a3b187a97814603e41ad37bf26e" name="a3d747a3b187a97814603e41ad37bf26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d747a3b187a97814603e41ad37bf26e">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt; &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements that compare <em>equivalent</em> to a given key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Type of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first element and past the last element of the range. </dd></dl>

</div>
</div>
<a id="a973f2399943dc681e617bb8b46e9244c" name="a973f2399943dc681e617bb8b46e9244c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973f2399943dc681e617bb8b46e9244c">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, std::pair&lt; <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a>, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt; &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with a given key.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators pointing to the first element and past the last element of the range.    </dd></dl>

</div>
</div>
<a id="a12d1730a14bac304cbd173c05cb2cbf2" name="a12d1730a14bac304cbd173c05cb2cbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d1730a14bac304cbd173c05cb2cbf2">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element associated with a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key value of an element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed (either 0 or 1). </dd></dl>

</div>
</div>
<a id="a49bb9a8de8e27cff97395d4fc527ad04" name="a49bb9a8de8e27cff97395d4fc527ad04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bb9a8de8e27cff97395d4fc527ad04">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given elements from a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of elements. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="a83036e3f167d28ba9afa943271fb5587" name="a83036e3f167d28ba9afa943271fb5587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83036e3f167d28ba9afa943271fb5587">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>An iterator to the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator following the removed element. </dd></dl>

</div>
</div>
<a id="a77aa062268245a84c4c27dcc01839814" name="a77aa062268245a84c4c27dcc01839814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aa062268245a84c4c27dcc01839814">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to an element with the given key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a5b47e5c447352298fca87921774c4a3d" name="a5b47e5c447352298fca87921774c4a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b47e5c447352298fca87921774c4a3d">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with a given key.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to an element with the given key. If no such element is found, a past-the-end iterator is returned.    </dd></dl>

</div>
</div>
<a id="abf771ba10ee17109769cecd68f0991c5" name="abf771ba10ee17109769cecd68f0991c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf771ba10ee17109769cecd68f0991c5">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a> &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with a key that compares <em>equivalent</em> to a given key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Other</td><td>Type of the key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to an element with the given key. If no such element is found, a past-the-end iterator is returned. </dd></dl>

</div>
</div>
<a id="a4c611a71d59737c941b1aaf29e64c9b7" name="a4c611a71d59737c941b1aaf29e64c9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c611a71d59737c941b1aaf29e64c9b7">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; is_transparent_v&lt; <a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> &gt; &amp;&amp;is_transparent_v&lt; <a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> &gt;, std::conditional_t&lt; false, Other, <a class="el" href="#a5c236223418b9ef327397424e2df24f8">const_iterator</a> &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with a given key.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key value of an element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to an element with the given key. If no such element is found, a past-the-end iterator is returned.    </dd></dl>

</div>
</div>
<a id="a9cd5632c26bf5281cfbbd7fbd9f85bf5" name="a9cd5632c26bf5281cfbbd7fbd9f85bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd5632c26bf5281cfbbd7fbd9f85bf5">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adc7feba2153b3764cc7789f31b926d78">allocator_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

</div>
</div>
<a id="afa1426bfb2ff55c9c4d0471303fcf6cc" name="afa1426bfb2ff55c9c4d0471303fcf6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1426bfb2ff55c9c4d0471303fcf6cc">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae62722d472417185388e952655b120e9">hasher</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function used to hash the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The function used to hash the keys. </dd></dl>

</div>
</div>
<a id="a92eced5574b8354b8357f79faf16fc23" name="a92eced5574b8354b8357f79faf16fc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eced5574b8354b8357f79faf16fc23">&#9670;&#160;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_constructible_v&lt; <a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a>, Arg &amp;&amp; &gt;, std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the container, if the key does not exist.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A key-value pair eventually convertible to the value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.    </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Type of the key-value pair to insert into the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada4ac1f5a3295d80d8bb4fa6387023db" name="ada4ac1f5a3295d80d8bb4fa6387023db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4ac1f5a3295d80d8bb4fa6387023db">&#9670;&#160;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the container, if the key does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A key-value pair eventually convertible to the value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. </dd></dl>

</div>
</div>
<a id="a3c94e139b8d65ac65df36161183a8a49" name="a3c94e139b8d65ac65df36161183a8a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94e139b8d65ac65df36161183a8a49">&#9670;&#160;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements into the container, if their keys do not exist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of elements. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71e1a562a523572405bbf0a53bb8535d" name="a71e1a562a523572405bbf0a53bb8535d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e1a562a523572405bbf0a53bb8535d">&#9670;&#160;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa53501af8bfd66b6bf45e8cfa844e180">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the container, if the key does not exist.    </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A key-value pair eventually convertible to the value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.    </dd></dl>

</div>
</div>
<a id="aafff57a203cd3fc561320bad6eeea0c3" name="aafff57a203cd3fc561320bad6eeea0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafff57a203cd3fc561320bad6eeea0c3">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the container or assigns to the current element if the key already exists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Type of the value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">value</td><td>A value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the element and a bool denoting whether the insertion took place. </dd></dl>

</div>
</div>
<a id="a9a9522dcd518bd3d73769d80d35606db" name="a9a9522dcd518bd3d73769d80d35606db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9522dcd518bd3d73769d80d35606db">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into the container or assigns to the current element if the key already exists.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Type of the value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">value</td><td>A value to insert or assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the element and a bool denoting whether the insertion took place.    </dd></dl>

</div>
</div>
<a id="ac2039886ad16466a4f9928dc737cd711" name="ac2039886ad16466a4f9928dc737cd711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2039886ad16466a4f9928dc737cd711">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a41a26ee3be60abf7b5ecf16c99948086">key_equal</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function used to compare keys for equality. </p>
<dl class="section return"><dt>Returns</dt><dd>The function used to compare keys for equality. </dd></dl>

</div>
</div>
<a id="a0ebd2095ae61e1908572efa33dc3df56" name="a0ebd2095ae61e1908572efa33dc3df56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebd2095ae61e1908572efa33dc3df56">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the average number of elements per bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>The average number of elements per bucket. </dd></dl>

</div>
</div>
<a id="a4818548e35a239228a5fae77af01e7f5" name="a4818548e35a239228a5fae77af01e7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4818548e35a239228a5fae77af01e7f5">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of buckets. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of buckets. </dd></dl>

</div>
</div>
<a id="a54a2dd65d401a992fd91fb8a91faea86" name="a54a2dd65d401a992fd91fb8a91faea86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a2dd65d401a992fd91fb8a91faea86">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum average number of elements per bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum average number of elements per bucket. </dd></dl>

</div>
</div>
<a id="a608539db499acbc3a7548421ea5d8709" name="a608539db499acbc3a7548421ea5d8709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608539db499acbc3a7548421ea5d8709">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the desired maximum average number of elements per bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A desired maximum average number of elements per bucket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45843ecba66cc9692ae4facac5461e4d" name="a45843ecba66cc9692ae4facac5461e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45843ecba66cc9692ae4facac5461e4d">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible number of elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum possible number of elements. </dd></dl>

</div>
</div>
<a id="a6ee333a078e7bc2b1035a911aff3b7ed" name="a6ee333a078e7bc2b1035a911aff3b7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee333a078e7bc2b1035a911aff3b7ed">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1dense__map.html">dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>This container. </dd></dl>

</div>
</div>
<a id="aadc4fceb8b438a1eeea0ee95f7885d60" name="aadc4fceb8b438a1eeea0ee95f7885d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc4fceb8b438a1eeea0ee95f7885d60">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1dense__map.html">dense_map</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1dense__map.html">dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>This container. </dd></dl>

</div>
</div>
<a id="a9b5784ca7ce9ab1ea46b303598f9987d" name="a9b5784ca7ce9ab1ea46b303598f9987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5784ca7ce9ab1ea46b303598f9987d">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses or inserts a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of an element to find or insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a19e0c8cdb0eef57582ce061a631b0a56" name="a19e0c8cdb0eef57582ce061a631b0a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e0c8cdb0eef57582ce061a631b0a56">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7cdfe85f102518543b7a684c9e8e3bd3">mapped_type</a> &amp; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses or inserts a given element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of an element to find or insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a7cea2e02e86eec9421ddaab64f15db6b" name="a7cea2e02e86eec9421ddaab64f15db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cea2e02e86eec9421ddaab64f15db6b">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cnt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves at least the specified number of buckets and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>New number of buckets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47084f57549451518ef81a0f7cbdae0e" name="a47084f57549451518ef81a0f7cbdae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47084f57549451518ef81a0f7cbdae0e">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a></td>          <td class="paramname"><span class="paramname"><em>cnt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for at least the specified number of elements and regenerates the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>New number of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38b10511f585724b7eb6e5f9556dea21" name="a38b10511f585724b7eb6e5f9556dea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b10511f585724b7eb6e5f9556dea21">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a38ef651a1992486e3d2151e7829777f1">size_type</a> <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a container. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in a container. </dd></dl>

</div>
</div>
<a id="ab88e2ffe045acc9aef1de4f77a23449b" name="ab88e2ffe045acc9aef1de4f77a23449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88e2ffe045acc9aef1de4f77a23449b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1dense__map.html">dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents with those of a given container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Container to exchange the content with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53111b5614ea1d29d8396279ebfd7d3e" name="a53111b5614ea1d29d8396279ebfd7d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53111b5614ea1d29d8396279ebfd7d3e">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place. </dd></dl>

</div>
</div>
<a id="ab2b0e98c01ad728022e5388535333fb1" name="ab2b0e98c01ad728022e5388535333fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b0e98c01ad728022e5388535333fb1">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Type , typename Hash , typename KeyEqual , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#acc07b299f15a57db885089cc1a31322d">iterator</a>, bool &gt; <a class="el" href="classentt_1_1dense__map.html">entt::dense_map</a>&lt; Key, Type, Hash, KeyEqual, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aeb9e305df1fc9e886d6c761324dc15ab">key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts in-place if the key does not exist, does nothing if the key exists.    </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key used both to look up and to insert if not found. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the constructor of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a bool denoting whether the insertion took place.    </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="entt_8hpp_source.html">entt.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
