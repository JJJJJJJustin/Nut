-----------------------------------相机&原理---------------------------------
》》》》查看这两篇说明，一个是坐标系统，一个是摄像机
（https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/）
（https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/）
来自 learn OpenGL ，很不错的网站，通俗易懂。

完全阐明了这一集的知识点。

-----------------------------------正交相机---------------------------------
》》》》原理：

最开始处于局部空间，在进行坐标变换和摄像机设置的时候，需要进行以下操作。

局部空间 * 模型矩阵 -> 世界空间		模型矩阵（类型：glm::translate）
世界空间 * 观察矩阵 -> 观察空间		模型矩阵（类型：glm::rotate）
观察空间 * 投影矩阵 -> 裁剪空间		模型矩阵（类型：glm::ortho/glm::prespective）
裁剪空间 + 坐标变换 -> 屏幕空间	自定义的操作（类型：glm::translate/glm::scale/glm::rotate）

一般会为坐标乘以 Projection * View * Model。
（比如着色器中会：gl_Position = projection * view * model * vec4(aPos, 1.0f); ）



》》》》inverse 函数在RecalcMatrix() 中的作用
首先，在 Cherno 的代码中，Cherno 将模型矩阵和观察矩阵设置后，放在 transform 中，然后赋值给 m_ViewMatrix.
其实，在代码中 m_ViewMatrix 实际上指代的应该是 m_ModelViewMatrix.


问题：
这时候讲讲为什么要使用 inverse 对 transform 进行转换，然后赋值给 m_ViewMatrix.

因为观察矩阵（View Matrix）通常需要描述观察者相对于世界空间的位置和方向，而不是物体相对于观察者的位置和方向。
也就是说该矩阵是用来作用于摄像机 camera 的，而不是作用于空间中的物体。

如果不进行逆操作，会将变换应用到物体上，那么结果将描述物体相对于 camera 的位置和方向，而不是 camera 相对于世界空间的位置和方向。



》》》》在着色器中，对坐标进行转换时进行乘法的顺序。
gl_Position = projection * view * model * a_Pos;	矩阵有先后顺序，而且需要在坐标之前先进行运算。




》》》》glm::value_ptr 的概念与作用
概念：获取 GLM 类型（如矩阵、向量等）内部数据的指针
作用：将 GLM 类型转换为指向C++内部数据的指针，以便将数据作为参数传递给 OpenGL 函数或其他需要 >指针参数<的函数

eg.
glm::mat4 matrix = glm::mat4(1.0f); 							// 创建一个4x4的单位矩阵
glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(matrix));	 // 将矩阵传递给OpenGL



-------------------------Moving to sandbox （含摄像机移动）--------------------------------------
》》》》关于垂直同步（V-Sync）的理解

》》V-Sync 用于解决图像撕裂的问题，什么是图像撕裂？为什么会出现图像撕裂？
一般情况下 GPU 的渲染速度会比屏幕的刷新率快，当 GPU 的渲染速度高于显示器的刷新率时，GPU 在显示器完成一次完整的刷新之前已经渲染了新的图像，而显示器可能还在显示上一帧的部分内容。
这导致在显示图像的某个位置上出现了不连续的线条，即图像撕裂。

》》
理解：
通过垂直同步对 GPU 和显示器的垂直刷新率进行同步，限制GPU输出的帧率，使其与显示器的刷新率保持一致。
（在 OpenGL 中，开启垂直同步后就是调用 glfwSwapInterval( 0 ) 产生这样的效果）
这样，GPU只会在显示器完成一次完整的垂直刷新周期后才输出下一帧图像，从而避免了图像撕裂现象的发生。

缺点：
因为GPU必须等待显示器完成垂直刷新周期后才能输出新的帧，所以不能充分利用显卡性能，可能导致输入延迟和帧率下降。
在 CS::GO 中，我会选择将其关闭 XD


--------------------------------------TimeStep-----------------------------------------------
》》》》 关于  Conversion Operators。 
》》》》 operator float() { return Variable } 是啥？
概念：
转换操作符（Conversion Operators）是一种特殊的成员函数，它们允许用户定义自定义类型之间的隐式或显式类型转换
语法：
operator target_type();

参考视频：
来自 Cherno 的（https://www.youtube.com/watch?v=OK0G4cmeX-I&t=368s）

--------------------------------------Transform（变换）--------------------------------------------------
》》》》关于 SetPositoin 和 变换 的区别
SetPosition 和 SetRotation 是对摄像机的变换。
这一集中我们需要对物体进行变换。

---------------------------------------Texture（纹理）-----------------------------------------------------
》》》》Cherno 对于纹理系统设计的一些展望。
没有什么知识点感觉。

关于其中的一些细节Cherno 会慢慢实现的，到时候我再就 PBR 之类的知识点进行学习。




---------------------------------------着色器抽象和统一变量-----------------------------------------------
》》》》参考文献：
来自 Learn opengl ：（https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/）
包含此集全部内容。（除了 ImGUI UI 的实现）


》》》》在类的成员函数之后调用 = default 是什么意思？

1.这个语句只可以出现在以下特殊成员函数之后：

默认构造函数
拷贝构造函数
移动构造函数
析构函数
拷贝赋值运算符
移动赋值运算符

2.意为指示编译器对其生成默认的实现，比如默认的构造函数。



》》》》关于 Cherno 将 Submit 的 Shader 类型的参数转换为 OpenGLShader 类型，这是否会报错？

问题概述：
在 C++ 中，你可以
1.将指向 派生类对象的指针/引用 转换为 指向基类对象的指针/引用,
2.将指向 基类对象的指针/引用 转换为 指向派生类对象的指针/引用。

但值得注意的是：
第一种情况称之为：向上转型（upcasting），无需进行显式转换
第二种情况称之为：向下转型（downcasting），需要进行显式类型转换。（正如 Cherno 所做的那样 std::d_p_cast<XX>(XX) ）


需要注意：
1.向上转型：

1.1在转换后如果只访问基类 Shader 中的成员，因为之前派生类对象 OpenGLshader 包含了基类 Shader 对象的所有成员，所以这没有什么差别，很安全。
1.2但是如果你希望转换后还能访问到派生类 OpenGLShader 中特有的成员，就需要用到虚函数这样动态加载的方法。

2.向下转型：

2.1向下转型是有风险的，因为只有当基类 Shader 指针或引用确实指向一个派生类 OpenGLShader 对象时，向下转型才是安全的。
（我们对于 Submit 函数 shader 传入的参数就是 OpenGLShader 类型的，所以安全）
2.2对于原来的参数， Shader shader，我们对其进行向下转换后，对于 OpenGLShader 类型的参数只能调用该派生类中的成员函数。


那么现在关于问题的答案是：不会。
//Cherno 传入了对应的派生类型的参数，而且处理的是向下转型, 使用的是派生类中的成员函数。




》》》》关于 std::dynamic_pointer_cast 

1.初始指针：直接使用类型名称声明指针类型 eg: int*
优点是不会使用额外的性能用来维护
缺点是不安全。

2.智能指针：std::dynamic_pointer_cast
优点是提供更高的类型安全性，比如可以自动管理内存、处理异常
缺点是使用额外的性能来维护程序正确性。（其实在 >小项目< 中没多少）

概念：
std::dynamic_pointer_cast 是 C++ 标准库中的一个模板函数，用于在运行时进行动态类型转换。

---------------------------------------------------------------------------------------------