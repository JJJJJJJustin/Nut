------------------ImGui docking & viewport 停靠和视口---------------------------------------
》》》》我所做的：

选择要使用的版本：
Cherno 使用的应该是1.67或者1.68版本中正在开发的、还未合并至主分支的 docking 中的代码。
做法：
所以我从ImGui v1.68 版本拉取了 docking 分支，将其作为个人库的一个 docking 分支（之前将 v1.66b 拉取到了个人库中）
然后在 docking 分支中上传对应的 premake5.lua 文件，以备使用。

报错：
对了，在子模块根目录下一开始 git checkout docking 时候，会报错
（error: pathspec 'docking' did not match any file(s) known to git）
此时 git branch 查看分支状况时候发现只有一个分支，这表明子模块还未更新
解决方法：
需要运行 git pull 拉取一下，然后可以查看到 docking 分支
（我的电脑上是这样的，虽然git pull 之后提示 Already up to date.）

》》注意：
由于我之前并没有定义 GLFW_INCLUDE_NONE,也没有像 Cherno 一样将 glad.h 和 GLFW.h 按照一定顺序包含
所以会导致一些错误，现已修复
可以参考：（http://t.csdnimg.cn/ogOD3）


》》》》关于库，分支的问题：

》》》一般情况下，一个库的不同分支中的文件一样吗？
答：
一个库的不同分支中的文件可能会有一些差异
不同分支可能会有针对不同功能需求的变化，比如新添加的特性或优化，这导致文件的更改。
或者说一个分支会是另一个开发路线，进行下一个版本的更新，这都将导致文件的不同。


》》》这两个分支一般会是什么关系，是两个相互没有什么联系的文件区域吗？
答：
分支之间可以相互独立，也可以有一定程度的关联。
一般来讲，一个库的不同分支之间通常是有一定联系的，他们可能代表着同一库的不同版本、不同特性或不同目标的开发路径。


》》》两个分支可以被单独的下载或者使用吗？
答：
分支通常可以单独下载或使用，具体取决于代码管理工具（如Git）的支持和库的发布方式。


》》》不同分支的文件管理的状态？
不同的分支中的文件可以分开单独管理。
可以在不同的分支中对同一个仓库中的文件进行不同的修改，而不会相互影响。


》》》tags 和 branches 的区别
tags:
	标签通常用于标识特定的版本或提交，一旦创建就不会随着新的提交而改变

branches:
	分支用于代表不同的代码开发路径，可以持续地进行提交和修改




》》》》git clone 克隆的代码来自哪个分支？
如果没有指定特定的分支或标签，git clone 命令会默认克隆源库的主分支（通常是 master 或 main 分支）。



》》》》关于 ImGui ，docking 分支从哪个版本开始正式投入使用？

从 ImGui 版本 1.80 开始，docking 功能被添加到主分支（master branch）中
因此在 1.80 版本及之后的版本，在主分支上便可以找到对 docking 功能的支持。


》》》从 1.80 开始，docking 功能已经被添加到主分支，为什么在主分支之外仍然存在一个 docking 分支呢？
因为开发团队为了保持代码的整洁和稳定性，在主分支之外继续维护一个用于开发和测试新功能的分支。

》》》如何理解被添加到主分支？
首先要知道，不同分支一般存放的代码有什么区别？
主分支：
	在开源项目中，通常会有一个主要的代码库，其中包含了当前版本的稳定代码以及最新的功能开发。
	这个主要的代码库就是主分支（master branch）或者叫主线。
其他分支：
	其他分支一般用于不同的目的，比如开发新功能、修复 bug、实验性质的功能等。

添加到主分支的意思？
一个项目通常包含多个分支，docking 恰恰就是用来开发和测试 docking（停靠）功能的。
当 docking 功能开发完成并被认为稳定时，开发者就将其合并到主分支中，成为主要代码库的一部分。

这就是添加到主分支的意思。



》》》》origin 在 Git 中的意思

origin 是默认的远程仓库名称，通常指向你从中克隆或者拉取代码的远程仓库。
我们一般使用 origin 来表示默认的远程仓库，就而不必每次都指定完整的远程仓库名称。

例如：
git checkout -b docking origin/docking。
从 ImGui 的源仓库克隆到本地，并且将其命名为 origin，同时你在个人的远程仓库也叫 ImGui，
那么 origin/docking 表示从名为 origin 的远程仓库中获取 docking 分支的引用。



》》》》子模块切换分支的方法

1. 进入子模块目录，找到想要切换分支的子模块目录，然后进入它的根目录切换到想要的分支：
git checkout branch_name		//这会将子模块切换到名为 branch_name 的分支。

2. 返回到子模版目录：
cd ..

3.1 提交主项目的变更：
git add path/to/submodule

3.2 git commit -m "Switch submodule to branch_name"
（可选：如果你只是想在本地切换子模块的分支，而不需要将这个更改记录在主项目的提交历史中，那么提交主项目的变更就不是必须的。）

之后如果需要将父仓库推送到远程仓库，使用命令 git push 进行推送



》》》》Git 指令中 fetch 和 pull 的区别
fetch:
	fetch 命令会从远程仓库下载新的提交和分支，但不会自动合并任何下载的更改到你当前的工作分支上，即不会修改你的工作目录中的文件
pull:
	pull 命令实际上是执行了 fetch 命令，然后立即将远程分支的更改合并到当前分支中
	（即 git fetch 和 git merge 命令的组合）




》》》》和 void ImGuiLayer::Begin( ) , void ImGuiLayer::End( ) ,void ImGuiLayer::OnImGuiRender( ) 的关系？
实际上参考 main.cpp 中的例子可以知道，m_ImGuiLayer 的 begin和end 分别对应

        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

	和

	// Update and Render additional Platform Windows
        // (Platform functions may change the current OpenGL context,
	// so we save/restore it to make it easier to paste this code elsewhere.
        //  For this specific demo app we could also call glfwMakeContextCurrent(window) directly)
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            GLFWwindow* backup_current_context = glfwGetCurrentContext();
            ImGui::UpdatePlatformWindows();
            ImGui::RenderPlatformWindowsDefault();
            glfwMakeContextCurrent(backup_current_context);
        }

Begin 是在真正的渲染前所做准备的工作（创建新帧）。
End 是对渲染内容进行的渲染呈现。

所以 OnImGuiRender ( )函数中对应main.cpp，应该实现的是
	// 1. Show the big demo window 
            if (show_demo_window)
                 ImGui::ShowDemoWindow(&show_demo_window);

	// 2. Show a simple window that we create ourselves. We use a Begin/End pair to create a named window.
        {
            static float f = 0.0f;
            static int counter = 0;

            ImGui::Begin("Hello, world!");                          // Create a window called "Hello, world!" and append into it.

            ImGui::Text("This is some useful text.");           // Display some text (you can use a format strings too)
	    ........
	    ........
            ImGui::End();
        }

        // 3. Show another simple window.
        if (show_another_window)
        {....省略......}

这便是真正要渲染的内容，其中正使用了 ImGui::Begin( ) ,ImGui::End( ) 
所以void ImGuiLayer::Begin( ) , void ImGuiLayer::End( ) ,void ImGuiLayer::OnImGuiRender( ) 的关系一目了然




》》》》关于 Cherno 所说的 OnUpdate 和 OnImGuiRender 的区别怎么理解

Application.cpp中：
		for (Layer* layer : m_LayerStack)
			layer->OnUpdate();				//执行逻辑更新

		m_ImGuiLayer->Begin();
		for (Layer* layer : m_LayerStack)
			layer->OnImGuiRender();			// 进行渲染操作（执行渲染更新）
		m_ImGuiLayer->End();

OnUpdate:
	OnUpdate() 函数被用来执行逻辑更新。通常情况下，OnUpdate() 函数用于更新应用程序的逻辑状态。
	例如更新对象的位置、处理输入事件、执行物理模拟等等。这个过程在每一帧都会执行，以确保实时修正逻辑操作内容。

在每一帧的渲染过程中，首先进行逻辑更新，然后才进行渲染操作

OnImGuiRender:
	得到正确的逻辑状态，进行内容的最新渲染结果。



》》》》Cherno 提出的问题
为什么在 Sandbox 中的运行语句会导致问题？

ImGui 被设置成静态库 .lib 
Nut( Hazel ) 是 .dll
Sandbox 是 .exe

现在 .dll（Hazel） 接受 .lib（ImGui） 中的函数，然后.exe（Sandbox）能够使用存放在 .dll 中的函数
虽然 .lib 中有所有的函数名称，但是 .dll 是动态加载的，如果一个函数在之后不被使用，.dll就不会执行那个函数。（.dll有能力删除.lib中未使用的内容）
正因为 .exe 使用的函数是 .dll 中没有加载过的（.dll 中没有包含的函数名称），所以在 .exe（Sandbox） 中使用这些函数就会导致程序崩溃。

-----------------------------渲染简介和渲染架构-------------------------------------------------

讲了一些基础，有点晦涩，介于之前看过 OpenGL 教程，也就马马虎虎看完了。
涉及的要点可以自己搜索，我建议还是将后面几集做完了回头看。

----------------------------渲染和维护----------------------------------------------------

》》》》Cherno在程序的属性页进行了修改，虽然我照做了，但并没有成功
于是我在 ImGui 的 premake 文件中做了修改：

    filter "system:windows"
        systemversion "latest"
        cppdialect "C++17"
        staticruntime "On"

        defines
        {
            "IMGUI_API=__declspec(dllexport)"
        }

然后成功实现了。（这个方法是我在youtube某一个视频下方找到的）

----------------------------------静态库和无警告-------------------------------------------
》》》》关于使用静态库的好坏，截取了一条评论作为参考。

Static libraries for these kinds of projects are totally fine! The reason is that the user is not gonna run more than 2-4 applications at the same time, actually, 90% of the users will probably run only one application at a time. Dlls make sense when creating OS-level libraries that are being used by hundreds of processes at the same time, like a windowing API (win32) for example, or Xorg (Linux). Then yes, it would be a waste of memory, but in the application layer usually, users run one application at a time.

熟肉：
此类项目的静态库完全没问题！ 原因是用户不会同时运行超过 2-4 个应用程序，实际上，90% 的用户可能一次只会运行一个应用程序。 当创建同时被数百个进程使用的操作系统级库时，Dll 很有意义，例如窗口 API (win32) 或 Xorg (Linux)。 是的，这会浪费内存，但在应用程序层中，用户通常一次运行一个应用程序。

------------------------------------渲染上下文----------------------------------------------------
》》》》什么是句柄
概念：句柄（Handle）是用于标识资源或对象的抽象概念。
形式：通常是一个数值或者引用，用来表示系统所管理的资源，例如内存块、文件、图形界面元素等。
作用：提供对某些资源的访问和操作方式，从而不需要直接访问资源本身。

举例：
		文件句柄（C语言实现）：
		FILE *fileHandle;
		fileHandle = fopen("example.txt", "r");		// fopen() 打开文件将返回一个文件指针，可以视作文件句柄
在程序中打开一个文件时，系统会返回一个文件句柄，用于标识该文件。
通过 fileHandle 获取句柄，可以用来对文件进行读取或写入操作。



》》》》为什么要抽象上下文？
为了拓展程序，增加其普适性。将上下文抽象，我们可以采用不同的API来进行上下文的设置。
比如使用OpenGL、Vulcan、DirectX 等。

----------------------------------------首个三角形-------------------------------------------------
》》》》涉及到很多OpenGL中的函数和知识，
可以看OpenGL的参考文档，
当然也可以看cherno的教程。
或者Learn OpenGL官网。

我看完了Cherno 的教程，LearnOpenGL学了一半，所以这里没啥要记的。
我可以把学习Cherno 时记得笔记放在笔记文件夹中，格式会有点乱，可以参考一下。
（为啥格式会这么乱啊，特地去修改了一次，如果格式任然乱也有可能因为缩放导致的，尝试缩放看看）


》》》》后面很多东西其实都是Cherno在他教程里面所教的，一定去看看他的视频。
基础知识和类的抽象什么的，稍有不同。Cherno的思路也很不错，赞。

-------------------------------OpenGL着色器---------------------------------------
》》》》std::make_ptr<> 和 reset 的概念与区别
区别：
std::make_ptr 创建智能指针的全局函数
reset 则是智能指针对象的成员函数


std::make_ptr<>
概念：
	是一个模板函数，用于创建智能指针，并将其初始化为指定类型的对象。
参数：
	要创建的对象的构造函数中的参数。
返回值：
	返回一个指向新分配的对象的智能指针。
---
.reset( )
概念：
	智能指针类的成员函数，用于重新分配该智能指针所拥有的资源。
参数：
	一个指针（指向新对象的指针）或者为空。
注意：
	如果智能指针之前拥有资源，该资源会被释放。
	如果不传递参数给 reset，则智能指针将被重置为空。



》》》》想起来一个东西，关于上一节的顶点属性的两个参数 stride（步幅） & offset（偏移量）不同情况下的理解

参数概念：
步幅（stride）指的是相邻顶点数据在数组中的字节间隔
偏移量（offset）指的是每个顶点属性在数组中的起始位置于数组本身开始位置之间的字节偏移量。

1.如果顶点是在结构体中放着的，像这样：
struct vertices {
    float position [3] ();
    float color[3] ();
}

实际的结构就会是：
{
	x1, y1, z1,
	x2, y2, z2,
	x3, y3, z3,
	r1, g1, b1,
	r2, g2, b2,
	r3, g3, b3
}
因为 stride 是同一个属性中每一个点之间所隔的距离，称之为步幅。
	所以 position 和 color 的 stride 就都会是 3 个浮点类型（3 * 4 = 12 byte），从 x1 到 x2、从r1 到 r2 都是相同的大小。
因为 offset 是指一个顶点属性开始时的位置的偏移量。
	position 的 offset 就会是 0 ，color 的 offset 就会是9个浮点类型（9 * 4 = 36 byte），offset 会根据顶点属性的不同而变化，
	每一个都不同，越向后某一个属性的 offset 就越大（累加）。

2.如果顶点所有属性全都放在一个数组中，像这样：
float vertices[] = {
      // 位置                // 颜色
      0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下
    -0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   // 左下
      0.0f,  0.5f, 0.0f,   0.0f, 0.0f, 1.0f    // 顶部
};

实际结构会是：{
      x1, y1, z1, r1, g1, b1,
      x2, y2, z2, r2, g2, b2,
      x3, y3, z3, r3, g3, b3
};
因为 stride 是同一个属性中每一个点之间所隔的距离，称之为步幅。
	所以 position 和 color 的 stride 就都会是 6个浮点类型（6 * 4 = 24 byte），从 x1 到 x2、从r1 到 r2 都是相同的大小。
因为 offset 是指一个顶点属性开始时的位置的偏移量。
	position 的 offset 就会是 0 ，color 的 offset 就会是3个浮点类型（3 * 4 = 12 byte），offset 会根据顶点属性的不同而变化，
	每一个都不同，越向后某一个属性的 offset 就越大（累加）。


这个问题曾让我犯难，希望这种解释足够明了。

------------------------------渲染接口抽象----------------------------------------
》》》》
