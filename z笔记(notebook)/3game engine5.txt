》》》》终于开始着色器库的设计，来看看着色器库是用来干嘛的。
着色器库的设置是静态的，用于自动加载着色器内容、诊断着色器。
高度抽象的设置可以为我们自动化识别接口，使在程序中的调用更加简洁，同时也隐藏了一些细节（自动化处理，不用手动显示设置）


》》》》以下是一些设计中的理解：

》》在 ShaderLibary 中，使用之前定义的指针 Ref 和 Scope，不需要包含头文件即可使用，为什么。
原理：
命名空间的作用域在整个程序中都有效，只要命名空间被正确声明和定义，其成员在程序的任何地方都可见。

不使用命名空间的话，直接在代码中使用 Nut::Ref 也是可行的，


》》关于Cherno对于从文件名截取着色器名称的手法，在 C++ 版本的逐步发展中，还有其他更便捷的方法。
原版：
	// Get Shader's name though filepath name
	// maybe : 1.assets/textures/shader.glsl		2./shader	3.shader.glsl	4.shader
	size_t lastSlash = filepath.find_last_of('/\\');
	lastSlash = (lastSlash == std::string::npos ? 0 : lastSlash + 1);
	size_t lastDot = filepath.rfind('.');
	lastDot = (lastDot == std::string::npos ? filepath.size() : lastDot);

	size_t count = lastDot - lastSlash;
	m_Name = filepath.substr(0, count);

新版：（C++ 17）
#include <filesystem>

std::filesystem::path path = filepath;
m_Name = path.stem().string(); // Returns the file's name stripped of the extension.

截取自评论：
@This new feature is very useful for use in Asset Managers as well which I'm currently implementing in my project, it supports native file path directory seeking.
@And it is bulletproof. His code isn't. If the path is "../testures/texture", the count will be negative, because the last dot is before the last slash. And this is a valid path.


--------------------------------------How to build 2D engine-------------------------------------------
没什么要记的，后面也都会涉及。这一集就是一个大概思路。
-------------------------------------Camera Controllers------------------------------------------------
》》》》大致思路
将实际控制通过 Camera Controller 来调用，而不是像以前一样通过 Camera 类来直接的修改和更新 Camera 的值。
现在的 Camera 可以认为是一个深层次的、存放了一些计算方法的库，controller 会调用这些方法，而用户只需要使用 Controller 来进行操纵。


》》》》std::max( )?
std::max 是 C++ 标准库中的一个函数模板，用于比较两个值，并返回其中较大的值。它定义在 <algorithm> 头文件中。


》》》》claudiaIDE 2019
一个可以更改 VS2019 背景的插件，这就是我昨天没有更选代码的原因。因为我去折腾壁纸了。
-----------------------------------Resizing--------------------------------------------------------------
》》》》minimized 这个变量的意义？
举个例子：
比如你在打一个游戏（英雄联盟），现在你打开了购买装备的界面，然后你又做了切换应用的操作。
此时游戏会被最小化到后台，购买界面也会随游戏被最小化。也不可以在脱离游戏界面时被操作。
只有你重新进入游戏界面，继续运行游戏时，这个购买界面才可以被响应（进行购买、关闭等操作）



》》》》关于函数设计时的思考。
application 中的 OnWindowResize 是为了让视口填充整个窗口。
OrthoGraphicCameraController 中的 OnWindowResized 是为了让视口中的物体在窗口大小调整时候比例自适应，而且呈现正确的效果。

但是函数
bool OrthoGraphicCameraController::OnWindowResized(WindowResizeEvent e)
{
	m_AspectRatio = (float)e.GetWidth() / (float)e.GetHeight();			//设置回调的宽高比
	m_Camera.SetProjectionMatrix(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);
	return false;
} 是这样设计的，
所以 m_AspectRatio 会随 width（分子） 的大小调整正确变化，但是与 Height（分母）的大小变化刚好相反。
而且由于 m_AspectRatio 是 width 除以 height ，所以当使用鼠标在窗口对角进行操作时（即对 Width 和 Height 同时进行改变），渲染的物体比例不变。

这是一个待处理的瑕疵。

----------------------------------------- maintenance ----------------------------------------------------------